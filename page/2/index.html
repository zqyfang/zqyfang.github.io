<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="飞奔的小猿猴">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="飞奔的小猿猴">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="飞奔的小猿猴">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>飞奔的小猿猴</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">飞奔的小猿猴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/面向对象二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/面向对象二/" itemprop="url">面向对象二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Net/" itemprop="url" rel="index">
                    <span itemprop="name">.Net</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><blockquote>
<p>实现多态的3种手段：1、虚方法 2、抽象类 3、接口</p>
</blockquote>
<h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><blockquote>
<p>将父类的方法标记为虚方法，使用关键字virtual,这个函数可以被子类重写<br>在子类的方法标记override</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">基本案例：</div><div class="line">class Program</div><div class="line">    &#123;</div><div class="line">        static void Main(string[] args)</div><div class="line">        &#123;</div><div class="line">            Person p = new Student(&quot;强哥&quot;);</div><div class="line">            p.sayHello();//输出 强哥是学生</div><div class="line">            Console.ReadKey();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    class Person</div><div class="line">    &#123;</div><div class="line">        private string _name;</div><div class="line">        public string Name</div><div class="line">        &#123;</div><div class="line">            get &#123; return _name; &#125;</div><div class="line">            set &#123; _name = value; &#125;</div><div class="line">        &#125;</div><div class="line">        public Person(string name)</div><div class="line">        &#123;</div><div class="line">            this.Name = name;</div><div class="line">        &#125;</div><div class="line">        public virtual void sayHello()//虚方法</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;&#123;0&#125;，是人类&quot;, Name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    class Student : Person</div><div class="line">    &#123;</div><div class="line">        public Student(string name) : base(name)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line">        public override void sayHello()//重写</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;&#123;0&#125;,是学生&quot;, Name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote>
<p>当父类中的方法不知道如何实现的时候，可以考虑将父类写成抽象类，方法写成抽象方法<br>抽象类可以存在非抽象成员，抽象本身没法实例化无法使用，但是其子类可以使用其非抽象成员。<br>抽象成员必须在抽象类当中。<br>子类继承抽象类后，必须把父类中的所有抽象成员都重写，除非子类也是抽象类<br>抽象类是否构造函数的，虽然不能被实例化</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">基本案例：</div><div class="line">class Program</div><div class="line">    &#123;</div><div class="line">        static void Main(string[] args)</div><div class="line">        &#123;</div><div class="line">            Animal a = new Dog();//注意抽象类不能实例化，所以此处使用其子类</div><div class="line">            a.show();</div><div class="line">            Console.ReadKey();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    abstract class Animal</div><div class="line">    &#123;</div><div class="line">        public abstract void show();//抽象方法不能有方法体</div><div class="line">    &#125;</div><div class="line">    class Dog : Animal</div><div class="line">    &#123;</div><div class="line">        public override void show()</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;狗再叫&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">解析：抽象类中抽象方法，存在的唯一意义，就是让子类重写，所以不论是虚方法，</div><div class="line">还是抽象类，本质都是子类重写方法实现多态。</div></pre></td></tr></table></figure>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><hr>
<pre><code>public :公开的
private:私有的，只能当前类内部访问
protected:受保护的，当前类和其子类访问
internal：只能在当前程序集中访问
protected internal: protected+internal

能够修饰类的访问修饰符：public internal(默认)
子类访问权限不能高于父类
</code></pre><hr>
<h1 id="简单工厂设计模式"><a href="#简单工厂设计模式" class="headerlink" title="简单工厂设计模式"></a>简单工厂设计模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">基本案例：</div><div class="line">namespace ConsoleApp2</div><div class="line">&#123;</div><div class="line">    class Program</div><div class="line">    &#123;</div><div class="line">        static void Main(string[] args)</div><div class="line">        &#123;</div><div class="line"></div><div class="line">            string info = Console.ReadLine();</div><div class="line">            factory(info);</div><div class="line">            Console.ReadKey();</div><div class="line">        &#125;</div><div class="line">		//工厂方法</div><div class="line">        public static void factory(string info)</div><div class="line">        &#123;</div><div class="line">            NoteBook nb = null;</div><div class="line">            switch (info)</div><div class="line">            &#123;</div><div class="line">                case &quot;联想&quot;:nb = new Lenovo();</div><div class="line">                    break;</div><div class="line">                case &quot;宏基&quot;:nb = new Acer();</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">            nb.show();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public abstract class NoteBook</div><div class="line">    &#123;</div><div class="line">        public abstract void show();</div><div class="line">    &#125;</div><div class="line">    public class Lenovo : NoteBook</div><div class="line">    &#123;</div><div class="line">        public override void show()</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;联想&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public class Acer : NoteBook</div><div class="line">    &#123;</div><div class="line">        public override void show()</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;宏基&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h1><hr>
<pre><code>值类型：int double char decimal bool enum struct   栈存储  原先值不随修改修改而修改
引用类型：string 数组 自定义类 集合 object 接口    堆存储  随之变化
特殊：字符串虽然是引用类型，但是是不可变的，所以结果类似值传递。
ref的作用：把原先的值传递变化为了引用传递
</code></pre><hr>
<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><ul>
<li>序列化：将对象转换为二进制</li>
<li>反序列化：将二进制转化为对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">案例：</div><div class="line">			Person p=new Person();</div><div class="line">            p.Name = &quot;强哥&quot;;</div><div class="line">            using (FileStream fsw = new FileStream(@&quot;C:\Users\zqyfa\Desktop\a.txt&quot;, FileMode.Open, FileAccess.Write))</div><div class="line">            &#123;</div><div class="line">                //开始序列化对象</div><div class="line">                BinaryFormatter bf = new BinaryFormatter();</div><div class="line">                //序列化</div><div class="line">                bf.Serialize(fsw, p);</div><div class="line">            &#125;</div><div class="line">            using (FileStream fsr = new FileStream(@&quot;C:\Users\zqyfa\Desktop\a.txt&quot;, FileMode.Open, FileAccess.Read))</div><div class="line">            &#123;</div><div class="line">                BinaryFormatter bf = new BinaryFormatter();</div><div class="line">                //反序列化</div><div class="line">                p = (Person)bf.Deserialize(fsr);</div><div class="line">                Console.WriteLine(p.Name);</div><div class="line">            &#125;</div><div class="line">            Console.ReadKey();</div><div class="line">//下面是要被序列化的类，该类必须被 [Serializable] 标记</div><div class="line"> [Serializable]  //要被序列化的类标记下</div><div class="line">    class Person</div><div class="line">    &#123;</div><div class="line">        private string _name;</div><div class="line">        public string Name</div><div class="line">        &#123;</div><div class="line">            get &#123; return _name; &#125;</div><div class="line">            set &#123; _name = value; &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="部分类"><a href="#部分类" class="headerlink" title="部分类"></a>部分类</h1><hr>
<pre><code>在同一文件下，不能出现两个名称相同的类，但是partial改变了这一结论
public partial class Person{}
public partial class Person{}
这就叫部分类，这两个类可以看作一个类，所有成员共用，其实就是一个类
</code></pre><hr>
<h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><blockquote>
<p>密封类不可以被其他类继承，但是可以继承其他类，使用关键字sealed<br>public sealed class Person{}</p>
</blockquote>
<h1 id="重写父类ToString方法"><a href="#重写父类ToString方法" class="headerlink" title="重写父类ToString方法"></a>重写父类ToString方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Person</div><div class="line">    &#123;</div><div class="line">        public override string ToString()</div><div class="line">        &#123;</div><div class="line">            return &quot;hello&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">此时Person类重写就是父类的虚方法ToString，否则直接打印的就是Person的命名空间</div></pre></td></tr></table></figure>
<h1 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public int Age&#123;</div><div class="line">	get;</div><div class="line">	set;</div><div class="line">&#125;</div><div class="line">自动属性书写更简便，效果等同字段加属性，唯一区别就是不能加限定。</div></pre></td></tr></table></figure>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><hr>
<pre><code>要使用多继承的时候使用接口，此处区分java,java中继承实现分开，c#不分开
如果继承时候多继承类不行，但是多继承接口是可以得。
接口中成员不可以添加访问修饰符，默认就是public
接口中不能出现有方法体的成员
接口中不能包含字段
接口中可以包含自动属性
接口中可以有方法，属性(必须是自动属性)，索引器，这三者本质都是方法
静态类，抽象类，接口不可被实例化
接口必须先继承类，在继承接口
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">接口基本案例：</div><div class="line">class Student : Person</div><div class="line">    &#123;</div><div class="line">        public void show()</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;实现接口方法&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public interface Person</div><div class="line">    &#123;</div><div class="line">        void show();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="显示接口：解决方法重名问题"><a href="#显示接口：解决方法重名问题" class="headerlink" title="显示接口：解决方法重名问题"></a>显示接口：解决方法重名问题</h1><blockquote>
<p>当接口和子类中方法名相同的时候，但是又想让子类同名方法不是多态的实现形式，而是<br>子类自己的方法(不是重写)。<br>类中默认访问修饰符石private<br>类中void Ifly.fly()，不能被访问修饰符修饰，这是固定写法，但是类中方法默认是private，<br>按理说，在外面调用时候是不能被调用，但是此时void Ifly.fly()其实是接口中方法的实现，<br>而接口中默认修饰符是public，所以外部能访问</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Bird : Ifly</div><div class="line">    &#123;</div><div class="line">        public void fly()</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;鸟在飞&quot;);</div><div class="line">        &#125;</div><div class="line">        /// &lt;summary&gt;</div><div class="line">        /// 显示接口</div><div class="line">        /// &lt;/summary&gt;</div><div class="line">        void Ifly.fly()//这就是显示接口</div><div class="line">        &#123;</div><div class="line">            Console.WriteLine(&quot;我是接口的飞&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public interface Ifly</div><div class="line">    &#123;</div><div class="line">        void fly();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//调用</div><div class="line">Ifly ifly = new Bird();</div><div class="line">ifly.fly();//接口飞</div><div class="line">Bird b = new Bird();</div><div class="line">b.fly();//鸟飞</div></pre></td></tr></table></figure>
<blockquote>
<p>总结：虚方法，抽象类，接口实现多态使用场景区别<br>虚方法：能抽取父类时候<br>抽象类：父类不知道如何实现的时候<br>接口：没有共同父类，但是可能有共同行为(例如飞)的时候</p>
<p>补充：<br>产生不会重复的唯一编码，使用Guid<br>因为Guid是一个结构体，内部有属性有方法，具体可以细细研究<br>产生唯一编码：Guid.NewGuid()即可。 </p>
</blockquote>
<h1 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MD5加密不可逆</div><div class="line">基本案例：</div><div class="line">			//md5是抽象类，不能直接实例化</div><div class="line">            MD5 md5 = MD5.Create();</div><div class="line">            string info = &quot;我是要加密的信息&quot;;</div><div class="line">            byte[] buffer = Encoding.Default.GetBytes(info);</div><div class="line">            byte[] nb=md5.ComputeHash(buffer);</div><div class="line">            Console.WriteLine(Encoding.Default.GetString(nb));</div><div class="line">但是如上方式，输出值，都是乱码，但是此乱码不是编码格式造成的。</div><div class="line">因为按照如上方式，可能把对应字符连接组成汉字等等，所以需要采用</div><div class="line">把buffer中每个元素都tostring然后连接，才能避免乱码。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">完整案例：</div><div class="line">			MD5 md5 = MD5.Create();</div><div class="line">            string info = &quot;我是要加密的信息&quot;;</div><div class="line">            byte[] buffer = Encoding.Default.GetBytes(info);</div><div class="line">            byte[] nb=md5.ComputeHash(buffer);</div><div class="line">            string nbinfo=&quot;&quot;;</div><div class="line">            for (int i = 0; i &lt; nb.Length; i++)</div><div class="line">            &#123;</div><div class="line">                nbinfo += nb[i].ToString();</div><div class="line">				//nbinfo += nb[i].ToString(&quot;x&quot;);这样的话就会将十进制字符串转成16进制</div><div class="line">            &#125;</div><div class="line">            Console.WriteLine(nbinfo);</div></pre></td></tr></table></figure>
<blockquote>
<p>补充：ToString添加不同参数有不同效果，例如转换成金额，日期等等。<br>ToString(“x2”)<br>x为 十六进制<br>2为  每次都是两位数<br>比如 0x0A ,若没有2，就只会输出0xA<br>假设两个数10和26<br>正常情况下十六进制显示0xA,0x1A,看起来不整齐<br>如果为x2,则为0x0A,0x1A。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/进制相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/进制相关/" itemprop="url">进制相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进制相关说明"><a href="#进制相关说明" class="headerlink" title="进制相关说明"></a>进制相关说明</h1><h2 id="进制转换基础"><a href="#进制转换基础" class="headerlink" title="进制转换基础"></a>进制转换基础</h2><h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><h4 id="八进制转十进制"><a href="#八进制转十进制" class="headerlink" title="八进制转十进制"></a>八进制转十进制</h4><blockquote>
<p>说明：该位数字乘以8和该位的权次方相加即可，小数点之后，权位为负数</p>
</blockquote>
<ul>
<li>案例：八进制72.45转十进制</li>
</ul>
<hr>
<p>7<em>8**1+2</em>8<strong>0+4*8</strong>（-1）+5<em>8*</em>（-2）=58.578125</p>
<p>注意：此时输出是字符串，而且参数二不加默认是把十进制字符串转十进制。</p>
<hr>
<h4 id="八进制转二进制"><a href="#八进制转二进制" class="headerlink" title="八进制转二进制"></a>八进制转二进制</h4><blockquote>
<p>二进制八进制对照关系表</p>
</blockquote>
<hr>
<pre><code>二进制      八进制
000                0
001                1
010                2
011                3
100                4
101                5
110                6
111                7
八进制125转二进制
125    001  010 101
</code></pre><hr>
<h4 id="八进制转十六进制"><a href="#八进制转十六进制" class="headerlink" title="八进制转十六进制"></a>八进制转十六进制</h4><hr>
<p>最好按照八进制转二进制，二进制转十六进制转换</p>
<p>八进制125转十六进制</p>
<p>125   -&gt;  001 010  101 </p>
<p>然后把转换的二进制四位一截取，直接按照八四二一码转值，按顺序(拼接)即可</p>
<p>例如此时：0101   0101  -》  5   5   -》 55<br>故而八进制125值为十六进制55</p>
<hr>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><hr>
<p>1.二进制转十进制（八四二一码即可）注意，按顺序（加和）即可<br>例如：10101010   -》   128   32   8   2   =》170</p>
<p>2.二进制转八进制(三位的二进制值拼接即可)<br>例如：10101010<br>说明：三位一截取，不够的补0<br>010 101 010   -&gt; 2   5   2  -&gt;252</p>
<p>3.二进制转十六进制（四位的二进制值拼接即可）<br>1010    1010    —&gt;   aa</p>
<hr>
<h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><hr>
<p>1.十进制转二进制（除以2余数逆向拼接即可）</p>
<p>例如：125转二进制   得值 1111101 </p>
<p>2.十进制转八进制（除以8余数逆向拼接即可）</p>
<p>例如：125   =》175</p>
<p>3.十进制转十六进制（除以16余数逆向拼接即可）</p>
<p>例如： 125   =》7d</p>
<hr>
<h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><hr>
<p>1.十六进制转二进制</p>
<p>例如：7d转二进制，7对应四位二进制数为（通过8421获取）0111<br>d对应为1101</p>
<p>7d  -&gt;  0111  1101</p>
<p>2.十六进制转八进制</p>
<p>转二进制后，三位截取获取8421码即可<br>001 111  101  -&gt;  1 7  5  -》175</p>
<p>3.十六进制转十进制</p>
<p>转二进制后每一位值相加即可</p>
<p>7d   -&gt;  0111  1101  -&gt;125</p>
<hr>
<h2 id="API使用集合"><a href="#API使用集合" class="headerlink" title="API使用集合"></a>API使用集合</h2><hr>
<p>A、十进制转换其他</p>
<p>　　十进制转成二进制 </p>
<p>　　Integer.toBinaryString(int i) </p>
<p>　　十进制转成八进制 </p>
<p>　　Integer.toOctalString(int i) </p>
<p>　　十进制转成十六进制</p>
<p>　　Integer.toHexString(int i)</p>
<p>B、其他转换十进制</p>
<p>　　二进制转十进制 </p>
<p>　　Integer.valueOf(“1010”,2).toString()</p>
<p>　　八进制转成十进制 </p>
<p>　　Integer.valueOf(“125”,8).toString() </p>
<p>　　十六进制转成十进制 </p>
<p>　　Integer.valueOf(“ABCDEF”,16).toString() </p>
<p>C、数字型字符串转数字</p>
<p>Integer.parseInt(str)</p>
<p>Float.parseFloat(str)</p>
<hr>
<h2 id="移位-针对的是二进制"><a href="#移位-针对的是二进制" class="headerlink" title="移位(针对的是二进制)"></a>移位(针对的是二进制)</h2><hr>
<p>1.java中左移右移分别对应  &lt;&lt;   &gt;&gt;</p>
<p>注意：向右移位是有符号操作，java使用最高位来表示数值的正负，负数最高位永远是1，一个以1开头的二进制数移位后仍将以1开头，一个以0开头的移位后仍将以0开头。</p>
<p>补充：针对有符号向左移动的时候，符号位不变，补充的每一位都是符号位。</p>
<p>即：-8&lt;<2 -="">   结果为：11111111111111111111111111100000。</2></p>
<p>2.无符号（只有右移）&gt;&gt;&gt;</p>
<p>说明：因为左移动是在后面补0，而符号位在最前面，所以左移即可，不需要无符号左移，两者等效。</p>
<hr>
<h2 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h2><blockquote>
<p>不论正数负数，在内存中都是以补码形式存储</p>
</blockquote>
<hr>
<p>正数：补码原码反码相同，即为计算出来的二进制。</p>
<p>负数：原码就是二进制，反码就是0，1取反（符号位不变），补码是反码加一。</p>
<p>总结：也就是说整数无需关心各种码直接二进制即可，只有负数才涉及转换，所谓的补码运算也就只是针对负数而言的。</p>
<hr>
<h2 id="byte数组案例"><a href="#byte数组案例" class="headerlink" title="byte数组案例"></a>byte数组案例</h2><hr>
<p>byte取值范围：-128~127，超过会被截取<br>b[0]= (byte) 129;//注意此处，127以下包括127都不会需要强制转换（针对正数而言）然后打印b[0]会得到-127。</p>
<p>例如：129超过byte取值范围界限，会被截取为byte类型的一字节</p>
<p>129对应的二进制是：00000000 00000000 00000000 10000001</p>
<p>强制转换后，只剩下最后部分一字节  10000001（原码）</p>
<p>反码：符号位不变其余取反，1  1111110</p>
<p>补码：反码加一，  &gt;&gt;&gt;  1  1111111  可知符号位1代表负数，后面七项相加为127。</p>
<p>故而最后结果为-127.</p>
<p>案例：[0]= (byte) -129输出结果为127.</p>
<p>-129：因为是负数，所以其在内存中以补码形式存储。</p>
<p>-129  原码：10000000  00000000 00000000 10000001</p>
<p>反码：符号位不变，其余取反，11111111 11111111 11111111 01111110</p>
<p>补码：反码加一  11111111 11111111 11111111 01111111<br>故而11111111 11111111 11111111 01111111才是内存中-129真正的存储形式</p>
<p>截取之后，01111111   -&gt;然后此时符号位为第一位0 ，为正数，而正数各种码一致也就是127.</p>
<p>补充：byte取值范围说明（-128~127）</p>
<p>注意：负数的补码是 其绝对值的原码的反码+1</p>
<p>最高位为符号位，取值是后面七位的结果</p>
<p>最大值为：0   111 1111  即为127</p>
<p>最小值为：1   000 0000  </p>
<p>又负数的补码是其绝对值的原码的反码加1.</p>
<p>128的原码 00000000 00000000 00000000 10000000</p>
<p>反码 ：00000000 00000000 00000000  011111111</p>
<p>补码：00000000 00000000 00000000  10000000</p>
<p>截取之后：1000000</p>
<p>可知10000000就是-128的补码</p>
<p>步骤：</p>
<p>1、byte为一字节8位，最高位是符号位，即最大值是01111111，因正数的补码是其本身，即此正数为01111111,十进制表示形式为127</p>
<p>2、最大正数是01111111，那么最小负是10000000(最大的负数是11111111，即-1)</p>
<p>3、10000000是最小负数的补码表示形式，我们把补码计算步骤倒过来就即可。10000000减1得01111111然后取反10000000因为负数的补码是其绝对值取反，即10000000为最小负数的绝对值，而10000000的十进制表示是128，所以最小负数是-128</p>
<p>4、由此可以得出byte的取值范围是-128到+127。</p>
<hr>
<h2 id="符号操作"><a href="#符号操作" class="headerlink" title="符号操作"></a>符号操作</h2><blockquote>
<p>0为假，1为真</p>
</blockquote>
<hr>
<p>~   按位取反</p>
<p>&amp;   按位与(有假则假)</p>
<p>^   按位异或(相同为假，不同为真)</p>
<p>|   按位或(有真则真)</p>
<hr>
<hr>
<p>案例：</p>
<p> byte[] b=new byte[3];</p>
<p> b[0]= (byte) 128;</p>
<p> System.out.println(b[0]);//-128</p>
<p> System.out.println(b[0]&amp;0xff);//128</p>
<p> System.out.println(b[0]&amp;0x000000ff);//128，0x000000ff和0xff等效，因为十六进制也是整型，十六进制一位是4个bit，故而会默认补充六个0.</p>
<p>是因为java的自动转型导致的，原理如下：</p>
<p>1、 128为int整数32位，前24为全部为0 后8位是1000 0000</p>
<p>2、（byte)128 转型为byte后首位是1，java认为是负数的补码标识<br>3、在System.out.println调用时，java类型系统会自动将byte类型转换为int，此时进行的是有符号左移操作，前24位全部为1，后8为位1000 0000，仍然是-128.</p>
<p>4、所以输出的为-128</p>
<p>tip：java在做字节操作的时候应为会发生自动的类型转换，又不支持无符号整数，要特别注意，通常需要使用 与&amp; 操作屏蔽掉自动扩展导致的错误的bit</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/基于Gulp的自动化工作流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/基于Gulp的自动化工作流/" itemprop="url">基于Gulp的自动化工作流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">Gulp中文网</a></p>
</blockquote>
<hr>
<pre><code>全局安装：npm install --global gulp
切换到项目目录：npm install gulp --save-dev
在项目根目录下创建一个名为 gulpfile.js 的文件
以下步骤都是在gulpfile.js中。
</code></pre><hr>
<h1 id="Gulp说明："><a href="#Gulp说明：" class="headerlink" title="Gulp说明："></a><strong>Gulp说明：</strong></h1><ul>
<li>gulp主文件，用于注册任务</li>
<li>gulp的作用机械化的完成重复性的工作</li>
<li>代码都是由node执行</li>
</ul>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a><strong>简单使用</strong></h1><ul>
<li>载入gulp模块</li>
</ul>
<blockquote>
<p>var gulp=require(‘gulp’);</p>
</blockquote>
<ul>
<li>注册任务，say是任务名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  gulp.task(&apos;copy&apos;,function()&#123;</div><div class="line">  //当gulp执行say任务时，会自动执行该函数</div><div class="line">  //console.log(&apos;say&apos;);</div><div class="line">  //合并，压缩之类的操作</div><div class="line">  //gulp.src：取一个文件</div><div class="line">  gulp.src(&apos;./src/index.html&apos;)</div><div class="line">  .pipe(gulp.dest(&apos;dist/&apos;));//将此处需要的操作传递进去,相当于一个环节</div><div class="line">  //.pipe()可以多次，比如先压缩再放入另一个文件夹</div><div class="line">  //dest是目的地的意思，不需要写文件名，原来是什么名字现在就是什么名字。</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gulp.task(&apos;dist&apos;,function () &#123;</div><div class="line">  gulp.watch(&apos;./src/index.html&apos;,[&apos;copy&apos;]);</div><div class="line">  //watch是监视参数一文件，一旦发生变法，执行参数二任务。</div><div class="line">  gulp.watch(&apos;./styles/demo.less&apos;,[&apos;style&apos;]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>执行</li>
</ul>
<hr>
<pre><code>然后切换到项目目录，因为在之前已经全局安装了gulp
此处执行gulp 任务名即可
</code></pre><hr>
<h1 id="gulp插件"><a href="#gulp插件" class="headerlink" title="gulp插件"></a><strong>gulp插件</strong></h1><hr>
<pre><code>转换less到css，需要用到插件gulp-less
切换到项目目录： npm install gulp-less --save-dev
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var less=require(&apos;gulp-less&apos;);</div><div class="line">gulp.task(&apos;style&apos;,function () &#123;</div><div class="line">  gulp.src(&apos;./styles/*.less&apos;)//*通配所有less文件</div><div class="line">  .pipe(less())</div><div class="line">  .pipe(gulp.dest(&apos;dist/css/&apos;));</div><div class="line">&#125;);</div><div class="line">//css压缩，插件gulp-cssnano</div><div class="line">//多个文件合并：gulp-concat</div><div class="line">var concat=require(&apos;gulp-concat&apos;);</div><div class="line">gulp.task(&apos;scripts&apos;,function () &#123;</div><div class="line">  return gulp.src(&apos;./lib/*.js&apos;)</div><div class="line">  .pipe(concat(&apos;all.js&apos;))</div><div class="line">  .pipe(gulp.dest(&apos;./dist/&apos;));</div><div class="line">  //把lib文件下所有js文件，合并到all.js并且输出到dist文件夹下面，名称还是all。</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>gulp四个api：watch task dest src .</p>
</blockquote>
<h1 id="其他常用gulp插件"><a href="#其他常用gulp插件" class="headerlink" title="其他常用gulp插件"></a>其他常用gulp插件</h1><ol>
<li>最小化js:gulp-uglify</li>
<li>创建本地服务器：gulp-connect</li>
<li>重命名文件：gulp-rename</li>
<li>压缩html:gulp-minify-html</li>
<li>最小化图像：gulp-imagemin</li>
</ol>
<h1 id="强大gulp插件"><a href="#强大gulp插件" class="headerlink" title="强大gulp插件"></a>强大gulp插件</h1><h2 id="browsersync功能强大（gulp-connect没有其强大）"><a href="#browsersync功能强大（gulp-connect没有其强大）" class="headerlink" title="browsersync功能强大（gulp-connect没有其强大）"></a>browsersync功能强大（gulp-connect没有其强大）</h2><blockquote>
<p><a href="https://browsersync.io/docs/gulp" target="_blank" rel="external">https://browsersync.io/docs/gulp</a></p>
</blockquote>
<h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><ul>
<li>切换到项目目录</li>
<li>执行npm install browser-sync gulp –save-dev</li>
<li>代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var gulp        = require(&apos;gulp&apos;);</div><div class="line">var browserSync = require(&apos;browser-sync&apos;).create();</div><div class="line">gulp.task(&apos;browser-sync&apos;, function() &#123;</div><div class="line">    browserSync.init(&#123;</div><div class="line">        server: &#123;</div><div class="line">            baseDir: &quot;./&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<pre><code>其中baseDir./指的是当前项目根目录
当执行完毕之后，多个窗口可以同步滚动，而且保存代码之后不需要刷新
另外命令行UI关键字之后会打印出本机管理页面的地址，复制到浏览器可以进入browserSync后台
其他几个关键字，还包括，其他人要访问后台的ip地址等，大家可以试试。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/回调机制浅尝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/回调机制浅尝/" itemprop="url">回调机制浅尝</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="回调机制浅尝"><a href="#回调机制浅尝" class="headerlink" title="回调机制浅尝"></a>回调机制浅尝</h1><h2 id="回调处于同步和异步之间，回调是异步的基础"><a href="#回调处于同步和异步之间，回调是异步的基础" class="headerlink" title="回调处于同步和异步之间，回调是异步的基础"></a>回调处于同步和异步之间，回调是异步的基础</h2><blockquote>
<p>回调使用场景：简单说来，延时操作，例如写完代码，运行模拟器测试，运行之后，你可以去干其他事情，当运行完毕，弹出提示运行完毕，这时候在可以去看结果显示。</p>
</blockquote>
<h2 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h2><blockquote>
<p>小王有作业，计算数学题目，但是他有别的事情，他打电话给小明,让小明计算，而他自己去忙别的事情，等计算完成之后，小明在打电话回来告诉小王答案。</p>
</blockquote>
<h2 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a>代码说明：</h2><blockquote>
<p>回调函数接口：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface CallBack &#123;</div><div class="line">	void sayResult(int str);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>定义小王：也就是调用者，其内部有回调函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Wang implements CallBack&#123;</div><div class="line">	private Li li;</div><div class="line">	public Wang (Li li) &#123;</div><div class="line">		this.li=li;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//小王调用小明的计算方法（此处十分重要，必须开子线程）</div><div class="line">	//回掉使用就是为了延时操作，如果不单开线程则li调用的对应方法耗时的时候，wnag这边也会阻塞在这，也就是说wang想出去玩是不可能的，所以单开线程，使之异步，则小王后面干吗还是不影响的，同时小李也在运算。</div><div class="line">	public void sendToLi() &#123;</div><div class="line">		new Thread(new Runnable() &#123;  </div><div class="line">            @Override  </div><div class="line">            public void run() &#123;   </div><div class="line">              li.addMethod(Wang.this,101);</div><div class="line">            &#125;  </div><div class="line">        &#125;).start();  </div><div class="line">	&#125;</div><div class="line">	//此处就是回调函数</div><div class="line">		public void sayResult(int result) &#123;</div><div class="line">			System.out.println(&quot;计算结果是：&quot;+result);</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>解析：要实现回调函数接口，要有被调用者的引用，此时就是li</p>
<hr>
<blockquote>
<p>定义小明：也就是被调用者</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Li &#123;</div><div class="line">	//计算方法</div><div class="line">	public void addMethod(Wang wang, int num) &#123;</div><div class="line">		int sum=0;</div><div class="line">		for (int i = 0; i &lt; num; i++) &#123;</div><div class="line">			sum+=num;</div><div class="line">		&#125;</div><div class="line">		//调用回调函数，把答案回传回去</div><div class="line">		wang.sayResult(sum);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>测试主函数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Li li=new Li();</div><div class="line">		Wang wang=new Wang(li);</div><div class="line">		wang.sendToLi();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>总结：回调，就是调用者（有被调用者的引用）有两个函数，一个是调用被调用者的方法，一个是回调函数。调用者（有调用者的引用），有真正的执行方法，执行完毕之后，通过调用者的引用然后回调调用者的回调方法。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/Vue文档初读（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/Vue文档初读（一）/" itemprop="url">Vue文档初读（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Vue初涉"><a href="#Vue初涉" class="headerlink" title="Vue初涉"></a><strong>Vue初涉</strong></h1><h2 id="一、Vue简介"><a href="#一、Vue简介" class="headerlink" title="一、Vue简介"></a>一、<strong>Vue简介</strong></h2><p>###构建单页面应用的渐进式框架，与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。</p>
<blockquote>
<p><a href="https://cn.vuejs.org" target="_blank" rel="external">Vue官网</a></p>
</blockquote>
<h2 id="二、Vue起步"><a href="#二、Vue起步" class="headerlink" title="二、Vue起步"></a>二、<strong>Vue起步</strong></h2><hr>
<pre><code>新手使用建议本地引用，下载js文件，正常引用即可。
</code></pre><hr>
<ul>
<li>废话不多说，直接上手</li>
<li><p>数据绑定</p>
<blockquote>
<p>html代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">			&#123;&#123; message &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>js代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var app = new Vue(&#123;</div><div class="line">	  el: &apos;#app&apos;,</div><div class="line">	  data: &#123;</div><div class="line">	    message: &apos;Hello Vue!&apos;</div><div class="line">	  &#125;</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>解析：el相当于element,故而按照js可以得到类名，id名等；data相当于数据，这两个命名规则是已定的。</em></p>
<ul>
<li><p>DOM元素绑定</p>
<blockquote>
<p>html代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-2&quot;&gt;</div><div class="line">  &lt;span v-bind:title=&quot;message&quot;&gt;</div><div class="line">    &#123;&#123;info&#125;&#125;</div><div class="line">  &lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>js代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var app2 = new Vue(&#123;</div><div class="line">  el: &apos;#app-2&apos;,</div><div class="line">  data: &#123;</div><div class="line">   message:&apos;我是鼠标悬浮提示信息&apos;,</div><div class="line">	info:&apos;哈哈&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>条件</p>
<blockquote>
<p>html代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-3&quot;&gt;</div><div class="line">  &lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>js代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var app3 = new Vue(&#123;</div><div class="line">	  el: &apos;#app-3&apos;,</div><div class="line">	  data: &#123;</div><div class="line">	    seen: true</div><div class="line">	  &#125;</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>解析：if是条件指令，seen是固定的，true显示，false不显示</em></p>
<ul>
<li><p>循环</p>
<blockquote>
<p>html代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-4&quot;&gt;</div><div class="line">  &lt;ol&gt;</div><div class="line">    &lt;li v-for=&quot;todo in todos&quot;&gt;</div><div class="line">      &#123;&#123; todo.text &#125;&#125;</div><div class="line">    &lt;/li&gt;</div><div class="line">  &lt;/ol&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>js代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var app4 = new Vue(&#123;</div><div class="line">  el: &apos;#app-4&apos;,</div><div class="line">  data: &#123;</div><div class="line">    todos: [</div><div class="line">      &#123; text: &apos;Learn JavaScript&apos; &#125;,</div><div class="line">      &#123; text: &apos;Learn Vue&apos; &#125;,</div><div class="line">      &#123; text: &apos;Build something awesome&apos; &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>解析：todos对应下面数据，至于todo随意命名即可</em></p>
<ul>
<li><p>数据处理</p>
<blockquote>
<p>js代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var app5 = new Vue(&#123;</div><div class="line">  el: &apos;#app-5&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;Hello Vue.js!&apos;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    reverseMessage: function () &#123;</div><div class="line">      this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>html代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-5&quot;&gt;</div><div class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>解析：vue使用简单，onclick事件在此处对应v-on指令的click</em></p>
<ul>
<li><p>数据双向绑定</p>
<blockquote>
<p>html代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-6&quot;&gt;</div><div class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;input v-model=&quot;message&quot;&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>js代码</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var app6 = new Vue(&#123;</div><div class="line">  el: &apos;#app-6&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;Hello Vue!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>解析：v-model指令代表数据双向绑定，整个页面其绑定的数据都会同时变化</em></p>
<h2 id="三、综合案例"><a href="#三、综合案例" class="headerlink" title="三、综合案例"></a>三、<strong>综合案例</strong></h2><blockquote>
<p>不赘述，直接上代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">		&lt;html lang=&quot;en&quot;&gt;</div><div class="line">		&lt;head&gt;</div><div class="line">		  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">		  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</div><div class="line">		  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</div><div class="line">		  &lt;title&gt;Document&lt;/title&gt;</div><div class="line">		&lt;/head&gt;</div><div class="line">		&lt;body&gt;</div><div class="line">		  &lt;div class=&quot;app&quot; v-bind:title=&quot;info&quot;&gt;</div><div class="line">		    &#123;&#123;message&#125;&#125;</div><div class="line">		    &lt;p v-if=&quot;seen&quot;&gt;&#123;&#123;hide&#125;&#125;&lt;/p&gt;</div><div class="line">		    &lt;ol&gt;</div><div class="line">		      &lt;li v-for=&quot;todo in todos&quot; &gt;</div><div class="line">		        &#123;&#123;todo.text&#125;&#125;</div><div class="line">		      &lt;/li&gt;</div><div class="line">		    &lt;/ol&gt;</div><div class="line">		    &lt;button type=&quot;button&quot; v-on:click=&quot;revers&quot;&gt;Reverse&lt;/button&gt;&lt;br/&gt;</div><div class="line">		    &lt;input v-model=&quot;message&quot; type=&quot;text&quot;&gt;</div><div class="line">		  &lt;/div&gt;</div><div class="line">		&lt;/body&gt;</div><div class="line">		&lt;/html&gt;</div><div class="line">		&lt;script src=&quot;./src/vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</div><div class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">		  var app=new Vue(&#123;</div><div class="line">		    el:&apos;.app&apos;,</div><div class="line">		    data:&#123;</div><div class="line">		      seen:true,</div><div class="line">		      message:&apos;Hello Vue!&apos;,</div><div class="line">		      info:&apos;mourse&apos;,</div><div class="line">		      hide:&apos;我显示咯！&apos;,</div><div class="line">		      todos:[</div><div class="line">		        &#123;text:&apos;a&apos;&#125;,</div><div class="line">		        &#123;text:&apos;b&apos;&#125;,</div><div class="line">		        &#123;text:&apos;c&apos;&#125;</div><div class="line">		      ]</div><div class="line">		    &#125;,</div><div class="line">		    methods:&#123;</div><div class="line">		      revers:function () &#123;</div><div class="line">		        this.info=this.info.split(&apos;&apos;).reverse().join(&apos;&apos;);</div><div class="line">		      &#125;</div><div class="line">		    &#125;</div><div class="line">		  &#125;)</div><div class="line">		&lt;/script&gt;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/Vue文档初读（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/Vue文档初读（二）/" itemprop="url">Vue文档初读（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="组件化构建"><a href="#组件化构建" class="headerlink" title="组件化构建"></a><strong>组件化构建</strong></h1><hr>
<pre><code>Vue提供了非常方便的组件化构建方案，可以用独立可复用的小组件来构建大型应用。
一个组件其实就是一个预定义的Vue实例。
</code></pre><hr>
<blockquote>
<p>下面来写一个类似于Vue提供的自动循环的无序列表</p>
</blockquote>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a><strong>自定义组件</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;todo-item&apos;, &#123;</div><div class="line">	props:[&apos;todo&apos;],</div><div class="line">  template: &apos;&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><em>解析：component组件的意思，template模板的意思，都是Vue固定的命名方案,props代表传入的参数，此时传入todo参数，下面todo.text引用</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;ol&gt;</div><div class="line">  &lt;todo-item v-bind:todo=&quot;item&quot; v-for=&quot;item in todos&quot;&gt;&lt;/todo-item&gt;</div><div class="line">&lt;/ol&gt;</div></pre></td></tr></table></figure></p>
<p><em>简单使用即可，注意名字和上面component一致。毕竟是自定义，所以要先绑定todo（可变，自定命名，只要和props传入一致即可）item,然后才能在v-for循环指令中使用item,使其对应上todo的数据</em></p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a><strong>代码实例</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</div><div class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</div><div class="line">  &lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;div class=&quot;app&quot;&gt;</div><div class="line">    &lt;ol&gt;</div><div class="line">      &lt;todo-item v-bind:todo=&quot;item&quot; v-for=&quot;item in todos&quot;&gt;&lt;/todo-item&gt;</div><div class="line">    &lt;/ol&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">&lt;script src=&quot;./src/vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">  Vue.component(&apos;todo-item&apos;,&#123;</div><div class="line">    props:[&apos;todo&apos;],</div><div class="line">    template:&apos;&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;&apos;</div><div class="line">  &#125;)</div><div class="line">  var app=new Vue(&#123;</div><div class="line">    el:&apos;.app&apos;,</div><div class="line">    data:&#123;</div><div class="line">    todos:[</div><div class="line">      &#123;text:&apos;a&apos;&#125;,</div><div class="line">      &#123;text:&apos;&apos;&#125;,</div><div class="line">      &#123;text:&apos;c&apos;&#125;</div><div class="line">    ]</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/Ubuntu命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/Ubuntu命令/" itemprop="url">Ubuntu命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂类/" itemprop="url" rel="index">
                    <span itemprop="name">杂类</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>ctrl+shift+加：放大终端</li>
<li>ctrl+减：缩小终端</li>
<li>ls；显示当前路径的文件以及文件夹</li>
</ul>
<hr>
<pre><code>延伸：ls / 显示根目录内容
   同理，还可以ls /bin等等
   ls -a:显示所有文件，包括隐藏文件
   ls -l:以列表形式显示内容
   ls -h:只这样使用和ls没区别，但是ls -l -h这样时候
   会显示文件大小(格式化后的文件大小)
   ls -a -h -l：等效于 ls -alh（无顺序之分）
   ls 2*:通配符*，此时表示显示2开头的文件或文件夹。
   ls 2?；通配符?,此时表示2开头且后面只有一位的文件或文件夹，例如23，25.
   ls 2[123]3:此时显示 213，223，233名称的文件，还可以这么写 2[1-3]3等效。
</code></pre><hr>
<ul>
<li>pwd:显示当前路径</li>
<li>touch 文件名：创建文件 如果文件名以.开头则是隐藏文件。</li>
<li>mkdir 文件夹名称：创建文件夹</li>
</ul>
<hr>
<pre><code>延伸：mkdir a/b/c/d -p:不加-p不能创建多级目录，因为不会自动创建，比如c目录没有
    d就没法创建，但是加上-p之后，就会自动创建。
</code></pre><hr>
<ul>
<li>clear：清空终端</li>
<li>–help：帮助文档，例如ls –help等效于 man ls</li>
<li>cat 文件名：查看文件内容</li>
<li>history：历史命令，刚刚执行过的命令</li>
<li>rm 文件或文件夹名称:删除文件或文件夹，可使用*通配符删除对应文件</li>
</ul>
<hr>
<pre><code>延伸：如果文件夹非空，不能直接删除
    rm 文件夹名称 -r:可以删除非空(和空)文件夹。
</code></pre><hr>
<ul>
<li>more 文件名:分屏显示内容，按F往下一屏，按B往上一屏，q退出。</li>
<li>ls -lah /bin |more:把对应路径下分屏显示。</li>
</ul>
<blockquote>
<p>注意：ll相当于 ls -la<br>|意思是把前面的执行内容，拿到|后面显示，|可以理解为一个管道。</p>
</blockquote>
<hr>
<pre><code>路径：两次tab可以显示当前能补全的所有内容
    cd /home/python/laowang:进入绝对路径
    相对路径：从当前目录开始算起
    绝对路径：从根目录(/)开始算起
    cd ..:返回上一级路径
    cd ./A:进入当前路径下的A文件夹里面
    cd ~：返回家目录，也就是此时的home/python
    cd -:返回上一次操作时候的目录。
写了很多命令不想执行，删除太麻烦：ctrl+c不执行
</code></pre><hr>
<ul>
<li>tree:以目录树方式显示</li>
</ul>
<hr>
<pre><code>重定向：
例如：ls &gt;xx.txt就会把本来ls输出的内容全部输入到当前目录的xx.txt文件中。
还有ls &gt;&gt;xx.txt是追加内容到原来文件的末尾的意思。一个&gt;会清空原来内容。
</code></pre><hr>
<hr>
<pre><code>链接：类似快捷方式
mv 原文件名 新文件名：重命名
    延伸：mv还可以移动文件 mv 111.txt laowang  ：把111.txt移动到laowang文件夹。

ln -s 原文件名 链接名称：创建软链接
ln 原文件名 链接名称：创建硬链接，相当于又创建一个文件名(类似于同一个文件鼬多个指向的入口)
所以删除原文件后，只是删除一个入口，例如链接还可以打开文件内容。
如何彻底删除硬链接文件：当删除所有硬链接个数时候，才会真正删除文件
查询文件硬链接数：当ls -lh时候，紧紧跟着文件名称的后面一个数字就是硬链接数。
</code></pre><hr>
<hr>
<pre><code>复制文件：
首先说明，cat可以一次查询不同文件内容，分行显示
如果 cat 1.txt 2.txt &gt;xxx.txt:就相当于把1，2两个文件内容复制到xxx.txt文件中。 

grep &quot;ntfs&quot; 1.txt:去1.txt中查找ntfs
grep &quot;^ntfs&quot; 1.txt:去1.txt中查找ntfs开头的内容
grep &quot;ntfs$&quot; 1.txt:去1.txt中查找ntfs结尾的内容
grep -n &quot;ntfs&quot; 1.txt:去1.txt中查找ntfs在哪一行
grep -v &quot;ntfs&quot; 1.txt:去1.txt中查找不包含ntfs的内容

cp:copy文本  cp 要复制的文件名称 新文件名称
如果拷贝的是文件夹，直接这样是不能copy的，加上-r就可以了，一般牵扯到文件夹然后失败的
加上-r一般都可以解决。其中-r放到前面后面都可行。
</code></pre><hr>
<hr>
<pre><code>find；
搜索文件：
find / -name &quot;*name*&quot;:在根目录下查找名称包含name的文件
find / -name &quot;.sh&quot;:根目录下查找后缀.sh结尾的文件
find / -name &quot;[A-Z]*&quot;:查找根目录下大写字母开头的文件。
find / -size 2M:查找根目录下文件大小为2m的文件
find / -size +2M:查找根目录下文件大于2m的文件
find / -size -2M:查找根目录下文件小于为2m的文件
find ./ -size+4K -size +2M:查找根目录下文件大于4k小于2m的文件
find ./ -perm 777 查找当前目录权限为77的文件或目录(注意此处还包括目录)
</code></pre><hr>
<hr>
<pre><code>tar:注意打包不会压缩，大小不变
打包：tar -cvf test.tar *.py 把当前目录的所有py结尾文件打包
解包：tar -xvf test.tar
压缩解压一：相对比压缩二会更小
压缩：tar -zcvf test.tar.gz *.py 把当前目录py文件压缩打包
解压：tar -zxvf test.tat.gz
压缩方式二：相对比压缩三更小
压缩：tar -jcvf test.tar.bz2 *.py
解压：tar -jxvf test.tar.bz2
注意：只要是tar情况下，tar -zxvf test.tat.gz -C laowang/
这意思是-大写的c，解压到指定文件夹，bz2和gz都可以使用

压缩方式三：
压缩：zip test.zip *.py
解压：unzip test.zip
zip情况下，解压到指定位置通过-d指定
</code></pre><hr>
<ul>
<li>which：<blockquote>
<p>例如：which ls:查看ls（当前命令，用的到底是bin文件夹下面的哪个文件，因为linux下命令<br>都是bin目录下的某个命令）</p>
</blockquote>
</li>
</ul>
<hr>
<pre><code>cal：列表形式打印出当天所在月整月日历
cal -y 2008:打印出2008年整年的日历
date:查看当前时间
date &quot;+%Y====%m====%d&quot;；输出2017====06====10
ps -aux:当前ubuntu正在开启的进程，输出完毕之后停止
top:显示当前ubuntu进程运行情况，且不停止
htop:显示更加人性化
kill pid数字:杀进程
kill -9 pid数字:强制杀进程，一定会被杀掉。
重启：reboot/init6
关机：shutdown -h/init0  立刻关机
shutdown -h +10:十分钟之后关机
shutdown -h 20:20:今晚八点二十关机
df：检查磁盘空间 可以使用df -h
du:当前路径所占用空间大小 可使用 du -h
</code></pre><hr>
<ul>
<li>ifconfig:查看当前电脑网络信息<blockquote>
<p>修改网卡地址：sudo ifconfig ens33 192.168.220.129<br>其中ens33就是其中一个网卡的名字，可以通过ifconfig查询出所有网卡名字</p>
</blockquote>
</li>
</ul>
<hr>
<pre><code>用户相关命令
useradd 账户名称：添加账户，需要权限，加sudo
但是这样没有设置密码是不能切换账户到新添加的用户的，此时
需要通过passwd 账户名然后先后输入两次密码，设置密码，没有权限则加上sudo
passwd不但可以创建密码，只要密码设置过，再次使用该命令，就是修改密码。
useradd 账户名 -m:会创建用户名同时创建家目录

su 账户名称：切换账户，类似于注销后登录。需要输入要切换到的用户的密码
whoami；显示当前账户名
who:当前登录的用户，有ip就是远程连接，没ip就是本机登录
exit：退出当前账户
远程登录电脑：ssh python@192.168.8.1
其中python是用户名，后面跟着的是电脑的ip。
在同一个终端开启多个标签：ctrl+shift+t
快速切换标签：alt+数字
uerdel 用户名:删除用户
userdel -r 用户名：删除用户名同时，删除对应的家目录
注意：切换目录时候，对比，su qiangge 和su - qiangge的区别
su qiangge :然后输入pwd:/home/python/Desktop
su - qiangge :然后输入pwd :/home/qiangge
也就是说加上-会切换到对应账户的家目录里面
cat /etc/passwd：查询用户详细信息。
切换到超级管理员:sudo -s(ubuntu中使用，其他linux是su root切换超级管理员)
groupadd 组名：创建组
可以进入group文件查看：cat /etc/group
groupdel 组名：删除组
还可以通过groupmod然后多按几次tab键显示所有组。
为普通用户加入sudo权限（超级管理员权限，不然sudo -s无效），
通过cat /etc/group |grep adm查询那些用户可以切换到超级管理员，
如果没有当前用户，可以通过命令添加进去(必须通过本来就有切换到超级管理员权限的用户名来操作).
sudo usermod -a -G adm 用户名
sudo usermod -a -G sudo 用户名
chown:修改文件所有者(也就是用户，可以通过ll查看)，chown 组名 文件名
chgrp:修改文件所属的组，chgrp 组名 文件名。
</code></pre><hr>
<h2 id="修改文件权限："><a href="#修改文件权限：" class="headerlink" title="- 修改文件权限："></a>- 修改文件权限：</h2><pre><code>d rwx  --x r--: d代表是否是文件夹(d代表是文件夹) 
后面三个一组，共三组(分别是文件拥有者的权限，同组的权限，其他人权限)
r:可读 w:可写  x:可执行(其中r可当作4，w为2，x为1)
u:文件拥有者 g:同组 o:其他人
字符法修改权限:chmod u=rwx 2.py
chmod u=r,g=r,o= 2.py
数字法修改权限：chmod 41 2.py代表修改拥有者权限为可读，同组权限为可执行，其他人无权限
</code></pre><hr>
<ul>
<li>vim相关编辑器：</li>
</ul>
<hr>
<pre><code>vi/vim 文件名称：创建文件(如果文件存在也是打开该文件)
i:vi进入编辑模式，按下i才能进行编辑，会光标前面插入字符
a:vi进入编辑模式，按下a会在光标后插入字符
o:在编辑模式下，输入字母o是下一行。
I：行首添加
A：行尾添加
O：上一行添加
yy:复制光标所在行
p:粘贴
dd:剪切光标所在行
4yy：光标所在行，开始向下复制的4行
2dd:光标所在行，开始向下删除两行
命令模式下上下左右的光标是无效:
h l 分别为左右移动光标，j k分别是下上
可见区域：快速定位
M：中间
L：最下面
H：最顶端

ctrl+f:下一页
ctrl+b:上一页
ctrl+u:向上翻半屏
ctrl+d:向下翻半屏
30G:快速定位到第30行
G：快速定位到整个代码最后一行
gg：快速回到整个代码的第一行

w:向后跳一个单词的长度，跳到下一个单词开始处
b:向前跳一个单词的长度，上i一个单词的开始处
D：从当前光标开始剪切，一直到行末
d0:从当前光标开始剪切，一直到行首
dw:删除当前光标的一个单词
u:撤销刚刚的操作
ctrl+r；反撤销
x:删除当前的光标位置，每次只会删除一个
X:删除光标前一个位置，每次只删除一个
v 加上下键选中多行或一行，然后两个&gt;&gt;:选中代码整体右移动，同理还有左移
V同v操作：区别在于，V选中是正行操作，而v是选择部分被操作
但是一直按下&gt;&gt;会很累，只需要在上面操作之后，按下.就是重复操作了
(：跳到上一片代码的开头
): 跳到下一片代码的开头
r:（替换先要进入编辑模式修改，太麻烦，次命令在命令模式下直接修改）
替换当前光标字符，只能替换一个
R:从当前光标开始，替换以及后面的字符
/：然后输入要搜索的内容，如果想取消搜索的颜色提示(难看)
可是在搜索一个不存在的即可。
N：搜索出来的情况下，调到上一个被搜索到的内容
n:搜索出来的情况下，调到下一个被搜索到的内容

末行模式：
整片替换：首先进入末行模式(:)，然后输入%s/要被替换内容/新内容/g
11，16s/要被替换内容/新内容/g：替换指定行到哪一行的内容
q!:不保存强制退出
w:保存
q:退出
shift+zz:相当于wq
</code></pre><hr>
<blockquote>
<p>进入末行模式然后保存文件：首先必须按下esc从编辑模式退回到<br>命令模式。然后在命令模式下输入:，然后输入wq即可保存文件<br>这其中任何情况下不想保存了，都可以esc退回到命令行模式</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/TCP及UDP小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/TCP及UDP小结/" itemprop="url">Socket通信小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP及UDP小结"><a href="#TCP及UDP小结" class="headerlink" title="TCP及UDP小结"></a>TCP及UDP小结</h1><h2 id="UDP双向发送"><a href="#UDP双向发送" class="headerlink" title="UDP双向发送"></a>UDP双向发送</h2><hr>
<p>udp是面向无连接的，所以不关心发送接收成功与否，双方都无应答，但是扔要建立连接只是没有三次握手的<br>过程，故而udp也可以设置建立连接超时时间：socket.setSoTimeout(time);<br>udp虽然也可以绑定端口号，但是不是说绑定之后，就按照绑定的端口发送数据，而是绑定端口其实就成了监听广播了。<br>jdk文档如下：<br>示例：DatagramSocket s = new DatagramSocket(null); s.bind(new InetSocketAddress(8888)); 这等价于：DatagramSocket s = new DatagramSocket(8888); 两个例子都能创建能够在 UDP 8888 端口上接收广播的 DatagramSocket。<br>故而udp无法绑定端口作为发送端，端口为系统自动分配然后作为监听端口的。</p>
<hr>
<h3 id="需要先运行的java类"><a href="#需要先运行的java类" class="headerlink" title="需要先运行的java类"></a>需要先运行的java类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">两个java文件都各自有发送端和服务端，案例如下</div><div class="line">public class UdpServer &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        DatagramSocket ds=new DatagramSocket(9090);</div><div class="line">        byte[] b=new byte[1024];</div><div class="line">        DatagramPacket dp=new DatagramPacket(b,b.length);</div><div class="line">        ds.receive(dp);</div><div class="line">        String string=new String(b,0,dp.getLength());</div><div class="line">        System.out.println(string);</div><div class="line">        ds.close();</div><div class="line"></div><div class="line"></div><div class="line">        DatagramSocket ds1=new DatagramSocket();</div><div class="line">        String info=&quot;udpserver发送的数据&quot;;</div><div class="line">        Inet4Address i4= (Inet4Address) Inet4Address.getByName(&quot;127.0.0.1&quot;);</div><div class="line">        DatagramPacket dp1=new DatagramPacket(info.getBytes(),info.getBytes().length,i4,10086);</div><div class="line">        ds1.send(dp1);</div><div class="line">        ds1.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>DatagramSocket不加端口号就是客户端，加上就是服务端（监听该端口号）</p>
</blockquote>
<h4 id="服务端创建步骤"><a href="#服务端创建步骤" class="headerlink" title="服务端创建步骤"></a>服务端创建步骤</h4><ul>
<li>创建DatagramSocket并监听本机某端口，服务器端无需指定ip，因为其本身就是监听状态</li>
<li>创建DatagramPacket，内部参数分别为byte数组，和其长度</li>
<li>然后ds接受dp，并把dp当做receive参数</li>
<li>最后关闭DatagramSocket</li>
</ul>
<h4 id="发送端创建步骤"><a href="#发送端创建步骤" class="headerlink" title="发送端创建步骤"></a>发送端创建步骤</h4><ul>
<li>创建DatagramSocket</li>
<li>创建DatagramPacket，参数分别为，byte类型数据，该byte的长度，通过Inet4Address得到的代表ip值，端口号</li>
<li>发送数据，参数为dp</li>
<li>关闭DatagramSocket</li>
</ul>
<h3 id="后运行的java类"><a href="#后运行的java类" class="headerlink" title="后运行的java类"></a>后运行的java类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class UdpUtils &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        DatagramSocket ds=new DatagramSocket();</div><div class="line">        String info=&quot;udpclient发送的数据&quot;;</div><div class="line">        Inet4Address i4= (Inet4Address) Inet4Address.getByName(&quot;127.0.0.1&quot;);</div><div class="line">        DatagramPacket dp=new DatagramPacket(info.getBytes(),info.getBytes().length,i4,9090);</div><div class="line">        ds.send(dp);</div><div class="line">        ds.close();</div><div class="line"></div><div class="line">        DatagramSocket ds1=new DatagramSocket(10086);</div><div class="line">        byte[] b=new byte[1024];</div><div class="line">        DatagramPacket dp1=new DatagramPacket(b,b.length);</div><div class="line">        ds1.receive(dp1);</div><div class="line">        String str=new String(b,0,dp1.getLength());</div><div class="line">        System.out.println(str);</div><div class="line">        ds1.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>之所以后执行，是因为java阻塞代码，先执行接受端，此时两个文件都有发送和接收，而且端口号不一样<br>可知，这是一个，a&gt;b而后b&gt;a的过程，其中是a发送到b的9090端口，b接收到数据后，回数据给a的10086端口。而不一定是a发送给b，b就回数据到a发送数据的端口。</p>
</blockquote>
<h2 id="tcp代码案例："><a href="#tcp代码案例：" class="headerlink" title="tcp代码案例："></a>tcp代码案例：</h2><blockquote>
<p>tcp绑定方法是用场景：ServerSocket 有一个不带参数的默认构造方法。通过该方法创建的 ServerSocket 不与任何端口绑定，接下来还需要通过 bind()方法与特定端口绑定。这个默认构造方法的用途是，允许服务器在绑定到特定端口之前，先设置ServerSocket 的一些选项。因为一旦服务器与特定端口绑定，有些选项就不能再改变了。不过一般情况下，直接使用常用方法即可。<br>例如：<br>ServerSocket serverSocket=new ServerSocket();<br>serverSocket.setReuseAddress(true); //设置 ServerSocket 的选项<br>serverSocket.bind(new InetSocketAddress(8080)); //与 8080 端口绑定</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">tcp客户端案例：</div><div class="line">public class TcpUtil &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        Socket s=new Socket(&quot;127.0.0.1&quot;,10086);</div><div class="line">        s.setSoTimeout(1000);</div><div class="line">        System.out.println(s.getPort());//连接的服务器端端口号，此时为10086</div><div class="line">        System.out.println(s.getLocalPort());//系统为客户端自动分配的端口号</div><div class="line">        System.out.println(s.getRemoteSocketAddress());//获取服务端的ip和端口号</div><div class="line">        System.out.println(s.getInetAddress());//获取服务器端ip</div><div class="line">        OutputStream os=s.getOutputStream();</div><div class="line">        os.write(&quot;客户端发送的信息&quot;.getBytes());</div><div class="line">        os.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">tcp服务端案例：</div><div class="line">public class TcpServer &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket ss=new ServerSocket(10086);</div><div class="line">        Socket s=ss.accept();</div><div class="line">        InputStream is=s.getInputStream();</div><div class="line">        byte[] b=new byte[1024];</div><div class="line">        int len=is.read(b);</div><div class="line">        String str=new String(b,0,len);</div><div class="line">        System.out.println(str+&quot;发送数据的ip：&quot;+s.getInetAddress());//获取客户端ip地址</div><div class="line">        System.out.println(str+&quot;发送数据的完整地址：&quot;+s.getRemoteSocketAddress());//获取客户端的完整地址，ip和端口号</div><div class="line">        System.out.println(s.getPort());//客户端的端口号</div><div class="line">        System.out.println(s.getLocalPort());//服务端监听端口，也即服务端端口，此时为10086</div><div class="line">        s.close();</div><div class="line">        ss.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>总结：相关方法tcp，udp通用，但是调用对象可能不同，例如udp服务端为datagrampacket<br>而tcp客户端就是socket调用，udp客户端时datagramsocket调用，tcp服务端时serversocket调用。</p>
<p>getPort():获取对方端口号，服务端则得到客户端端口号，客户端则得到服务端端口号<br>getLocalPort():获取本地端口号，例如，服务端获取就是服务端监听也即服务端端口号<br>getInetAddress():获取对方ip地址<br>getRemoteSocketAddress()：获取对方完整地址，包括ip和端口号<br>getLocalAddress():获取本地ip地址</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/Python知识点(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/Python知识点(一)/" itemprop="url">Python知识点(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><hr>
<pre><code>单行注释：# 我是注释
多行注释：,,, 我是多行注释 ,,, （还可以用三个双引号）
py2：为了支持中文
# coding=utf-8  或者 #-*- coding:utf-8 -*-
</code></pre><hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote>
<p>num=10 #定义变量，python会自动推导类型</p>
<h1 id="input"><a href="#input" class="headerlink" title="input"></a>input</h1><hr>
<pre><code>high=input(&quot;请输入你的身高：&quot;) #接收输入内容
age=18
print(&quot;age的值是%d&quot;%age) # %s是字符串占位符
在py3中input接收到内容当作字符串赋值给前面变量
在py2中input接收到内容当作代码执行后赋值给变量
说明：比如说input在py2下输入是laowang，最后就是value=laowang
会报错，代码赋值给value这肯定错了
py2下input接受1+1，则value值是2，当作代码执行了
py2下面实现py3接受字符串效果，使用raw_input()即可。
</code></pre></blockquote>
<hr>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><hr>
<pre><code>数字：int(有符号整型) long(长整形，也可以代表八进制，十六进制)
float(浮点型) complex(复数)
布尔型：True,False
字符串：String
List:列表
Tuple:元组
Dictionary；字典
</code></pre><hr>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><blockquote>
<p>字母，数字，下划线，且数字不能开头。</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><hr>
<pre><code>在python中可以用字符串乘以数字，输出就是数字个该字符串
幂运算符：**
一次输出多个变量：
print(&quot;字符串%s,......整型值%d....&quot;,%(name,age));
python字符串比较可以直接使用==.
</code></pre></blockquote>
<hr>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">not:</div><div class="line">a=int(input(&quot;请输入数字&quot;))</div><div class="line">if not(a&gt;10):</div><div class="line">    print(&quot;不是大于10&quot;)</div></pre></td></tr></table></figure>
<h1 id="补充点"><a href="#补充点" class="headerlink" title="补充点"></a>补充点</h1><hr>
<pre><code>python中没有do while
print打印默认换行，print(&quot;*&quot;,end=&quot;&quot;)这样就不换行了
python中只有j+=1,没有j++
</code></pre><hr>
<h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for循环可以直接遍历字符串</div><div class="line">for item in name：</div></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">组合字符串：两种方式</div><div class="line">+：如果是字符串相加即时组合，如果是数字+就是计算</div><div class="line">f=&quot;======%s=======&quot;%(a+b)</div><div class="line">下标和切片：</div><div class="line">name=“&quot;qiang&quot;;</div><div class="line">name[1]</div><div class="line">name[-1]//最后一个元素</div><div class="line">len(name)  字符串长度</div><div class="line">name[1:3] 切片，包左不包右</div><div class="line">name[-2:] 取最后两个</div><div class="line">name[1:5:2] 每隔2(步长)取</div><div class="line">name[-1:0]这样写是什么也取不出来的</div><div class="line">name[-1:0:-1]这样是逆序取字符串，但是这样取不出来最开始的字符</div><div class="line">name[-1::-1]完整的逆序取字符串，等效于name[::-1]</div><div class="line">mystr.find(&quot;world&quot;) 返回从左边开始的匹配的字符串中第一个字符的下标(此时是w)</div><div class="line">如果没找到返回-1</div><div class="line">mystr.rfind(&quot;world&quot;) 返回从右开始的下标，注意此时返回的是右边开始的第一个匹配的</div><div class="line">字符串world中w字符的下标(下标还是从左往右数的数字)</div><div class="line"></div><div class="line">mystr.index(&quot;world&quot;)如果该字符存在，则和find效果等同，但是如果没找到，则程序直接报错，同理也有rindex</div><div class="line">mystr.count(&quot;world&quot;)查询出现次数，不存在则返回0</div><div class="line">mytsr.replace(&quot;world&quot;,&quot;WORLD&quot;)  替换字符串中小写world变为大写，返回新字符串，原字符串不变</div><div class="line">数字字符串元组是不可变类型，所以相关操作，一般都是返回新的，本身不变</div><div class="line">mytsr.replace(&quot;world&quot;,&quot;WORLD&quot;，1)如果字符串有多个小写的world，那么此时只替换第一个，如果不写参数三，则全部替换</div><div class="line">mystr.split(&quot; &quot;)把字符串mystr按照空格切割(被切割的部分已经没有了，此时空格就没有了)，并返回一个列表[]</div><div class="line"> mystr.capitalize()首字母大写</div><div class="line">mystr.title() 每个单词首字母都大写</div><div class="line">mystr.startswith() 是否已什么开头，返回布尔值</div><div class="line">mystr.endswith()</div><div class="line">mystr.lower()</div><div class="line">mystr.upper()</div><div class="line">mystr.ljust(10)   &apos;hello     &apos; 左对齐并空格填充</div><div class="line">mystr.rjust(10)   &apos;     hello&apos;</div><div class="line">mystr.center(10)  &apos;   hello  &apos;</div><div class="line">mystr.lstrip()删除字符串左边空格</div><div class="line">mystr.rstrip()删除字符串右边空格</div><div class="line">mystr.strip()删除字符串两边空格</div><div class="line">mystr.partition(&quot;itcast&quot;)以参数字符串为中心，分割字符串为三部分  </div><div class="line">返回：(hello itcast  qiang)元组</div><div class="line">mystr.rpartition(&quot;itcast&quot;) 从右边开始找，进行分割</div><div class="line">mystr.splitlines() 把字符串(内部有\n)按照换行进行切割，并返回列表list</div><div class="line">mystr.isalpha() 所有字符都是字母，返回布尔值</div><div class="line">mystr.isdigit 字符串只包含数字，返回布尔值</div><div class="line">mystr.isalnum 字符串是否只包含数字和字母，返回布尔值</div><div class="line">mystr.isspace 字符串是否只包含空格，返回布尔值</div><div class="line">mystr.join(str)每个字符后面插入str，构造出一个新的字符串</div><div class="line">li=[&quot;my&quot;,&quot;name&quot;,&quot;is&quot;,&quot;qiang&quot;]</div><div class="line">str=&quot; &quot;</div><div class="line">str.join(li)  &apos;my name is qiang&apos;</div><div class="line">str=&quot;-&quot;</div><div class="line">str.join(li) &apos;my-name-is-qiang&apos;</div></pre></td></tr></table></figure>
<hr>
<pre><code>面试题：切割字符串中的空格或\td等空白字符
解析：直接使用result=mystr.split（）默认不加参数，就是直接去除这类空白字符，都会进行切割。返回的是列表
然后利用join方法在拼接成字符串
&quot;&quot;.join(result)，这样不加空格的字符串&quot;&quot;，使用join就可拼接列表中字符
</code></pre><hr>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><hr>
<pre><code>python中列表可以存储不同数据类型
name=[1,&apos;a&apos;,&quot;afba&quot;,3.14]
添加：name.append(&quot;强&quot;)  如果append是添加的是可迭代对象，例如列表会整体添加进去，区别于
extentd。例如:[1,2,3,[4,5]]
补充案例：
a=[1,2,3]
b=[4,5]
a=a.append(b)
输出a结果是None，因为右边没有返回值


插入：name.insert(1,&quot;heh&quot;)
连接列表：1.使用+（此时变化的是新的name2=name+name1而不是name） 2. name.extend(name1) 把name1列表添加到name列表，此时name变化,注意，extentd内部只能放入可迭代对象，不能是单一数字这种。
删除：
name.pop() 删除name最后一个元素并返回删除的元素
name.remove(&quot;曾&quot;) 删除指定元素，如果存在多个相同元素，则只删除从左开始第一个，无返回值
del name[1]删除指定索引的元素
取出：name[2:5]同字符串的切片，包左不包右
替换：name[0]=&quot;强&quot;
&quot;强&quot; in name: 判断字符串&quot;强&quot;是否在name列表中，同理还有not in
</code></pre><hr>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">person=&#123;&quot;age&quot;:19,&quot;name&quot;:qiang&#125;</div><div class="line">增加：person[&quot;没有的key&quot;]=value</div><div class="line">删除：del person[key]  无返回值</div><div class="line">查找：1. person[key]  没有的的话会程序崩溃  2.person.get(key) 没有key也不会报错</div><div class="line">修改：person[key]=新value</div><div class="line"></div><div class="line">python特有的遍历：</div><div class="line">for item in name:</div><div class="line">	pass</div><div class="line">else:</div><div class="line">	pass</div><div class="line">这种else是不论怎么样都会执行了除非在for内部加判断然后break了</div><div class="line"></div><div class="line">字典相关操作：</div><div class="line">len():字典的长度</div><div class="line">keys():字典所有key的列表 dict_keys([&apos;name&apos;, &apos;age&apos;])</div><div class="line">values():字典所有value的列表   dict_values([&apos;qiang&apos;, 13])</div><div class="line">items():字典(键值)元组的列表   dict_items([(&apos;name&apos;, &apos;qiang&apos;), (&apos;age&apos;, 13)])</div><div class="line">注意：上面三个返回值，都是py3的返回，在py2中，返回就是元组，外面没有dict_...包裹</div><div class="line"></div><div class="line"></div><div class="line">拆包：</div><div class="line">a=(11,22)</div><div class="line">b,c=a</div><div class="line">则b=11   c=22</div></pre></td></tr></table></figure>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h2><blockquote>
<p>元组和列表类似，列表使用方括号，元组使用小括号，元组的元素不能修改<br>name=(1,2,3)</p>
</blockquote>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def 函数名():</div><div class="line">	pass</div><div class="line"></div><div class="line">函数返回值：</div><div class="line">def test():</div><div class="line">	a=1</div><div class="line">	b=2</div><div class="line">	c=3</div><div class="line">	return a,b,c  #等效于return(a,b,c)</div><div class="line">说明：函数一次性返回多个值，默认会被封装成元组返回，当然也可以手动封装成列表等返回</div></pre></td></tr></table></figure>
<h1 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h1><hr>
<pre><code>定义全局变量之后，如果内部有同名的局部变量
但是如果还是想使用全局变量，可以内部用global修饰，这样就是指明使用的是全局变量
全局变量，必须放在函数调用之前即可（重要）
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">函数：</div><div class="line">num =10</div><div class="line">def test():</div><div class="line">	global num</div><div class="line">    num=num+1</div><div class="line">    return num</div><div class="line">说明：函数使用全局变量的时候，如果不在函数内部加以声明，会报错，这点和java</div><div class="line">不同，另外，如果使用全局的字典，列表，则global xx这个函数内声明可省略。</div><div class="line"></div><div class="line">缺省参数：</div><div class="line">def test(a,b=33,c=44):  b ,c  被称为缺省参数</div><div class="line">	return a+b</div><div class="line"></div><div class="line">test(a,c=55) c被称为命名参数</div><div class="line"></div><div class="line">不定长参数：</div><div class="line">def test(a,b,*args):</div><div class="line">   sum=0</div><div class="line">   sum+=(a+b)</div><div class="line">   for item in args:</div><div class="line">        sum+=item</div><div class="line">   return sum</div><div class="line">print(test(1,2,3,4,5,6))</div><div class="line">输出21 ，*args会被封装成一个元组此时为(3,4,5,6),注意可变参数一定要放到参数最后一个。</div><div class="line"></div><div class="line">案例：</div><div class="line">  1 def test(a,b,c=33,*args,**kwargs):</div><div class="line">  2     print(a,b)</div><div class="line">  3     print(c)</div><div class="line">  4     print(args)</div><div class="line">  5     print(kwargs)</div><div class="line">  6 test(1,2,44,1,44,d=&quot;qiang&quot;,e=&quot;zeng&quot;)</div><div class="line">输出：</div><div class="line">1 2</div><div class="line">44</div><div class="line">(1, 44)</div><div class="line">&#123;&apos;d&apos;: &apos;qiang&apos;, &apos;e&apos;: &apos;zeng&apos;&#125;</div></pre></td></tr></table></figure>
<hr>
<pre><code>注意：传入的key=value形式的参数，如果位于最后，会被封装成字典形式
另外此种形式，不能在44位置，写c=44，因为后面有**kwargs。如此会造成
识别误区，因为会被当成封装进入字典的一部分，但是规定字典那部分必须放在最后
同时，不能出现a=&quot;&quot;这样的，因为也会出现识别错误，因为前面参数有a。
</code></pre><hr>
<h2 id="拆包："><a href="#拆包：" class="headerlink" title="拆包："></a>拆包：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">案例：</div><div class="line">  1 def test(a,b,c=33,*args,**kwargs):</div><div class="line">  2     print(a,b)</div><div class="line">  3     print(c)</div><div class="line">  4     print(args)</div><div class="line">  5     print(kwargs)</div><div class="line">  6</div><div class="line">  7 A=(7,8,9)</div><div class="line">  8 B=&#123;&quot;d&quot;:&quot;qiang&quot;,&quot;e&quot;:&quot;zeng&quot;&#125;</div><div class="line">  9 test(1,2,44,*A,**B)</div><div class="line"></div><div class="line">  输出：</div><div class="line">	1 2</div><div class="line">	44</div><div class="line">	(7, 8, 9)</div><div class="line">	&#123;&apos;e&apos;: &apos;zeng&apos;, &apos;d&apos;: &apos;qiang&apos;&#125;</div><div class="line">注意：即使B里面也不能出现和前面形参名称相同的key，例如此时的a,b</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">案例一：</div><div class="line">  1 def test(a,b,c=33,*args,**kwargs):</div><div class="line">  2     print(a,b)</div><div class="line">  3     print(c)</div><div class="line">  4     print(args)</div><div class="line">  5     print(kwargs)</div><div class="line">  6</div><div class="line">  7 A=(7,8,9)</div><div class="line">  8 B=&#123;&quot;d&quot;:&quot;qiang&quot;,&quot;e&quot;:&quot;zeng&quot;&#125;</div><div class="line">  9 test(1,2,44,A,B)</div><div class="line"></div><div class="line"></div><div class="line">输出：</div><div class="line">1 2</div><div class="line">44</div><div class="line">((7, 8, 9), &#123;&apos;e&apos;: &apos;zeng&apos;, &apos;d&apos;: &apos;qiang&apos;&#125;)</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><hr>
<pre><code>id(a)；变量a在内存中的地址
变量名称1=变量名称2：统统都是地址传递(引用)，注意是变量名赋值
例如：a=10   b=a  此时a,b都指向10 此时修改a=11，则b还是10，指向不变，a已经变化为11.
所谓的引用传递，指的是全都是引用传递，不论什么类型，理论上都可以修改，但是不可变类型是不可修改的。

不可变类型：数字，字符串，元组
字典的key只能是不可变类型，因为取出value的值的时候，是通过key计算出来对应的内存地址的，key固定通过哈希算法才能计算出唯一的不变地址索引，才能正确的
修改，查询对应的value值。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/OC语言笔记_04md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/OC语言笔记_04md/" itemprop="url">OC语言笔记_04</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Object-C/" itemprop="url" rel="index">
                    <span itemprop="name">Object C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h1><blockquote>
<p>C语言数组的弊端：<br>int array[4]={10,89,27,76};<br>只能存放一种类型的数据<br>不能动态添加数组元素，不能方便的动态删除数组元素(长度固定)</p>
</blockquote>
<hr>
<pre><code>NSArray注意：
只能存放任意oc对象，并且是有顺序的
不能存放非oc对象，比如int/float/struct等
它是不可变的，一旦初始化完成，里面内容固定，不能删除里面的元素，也不能追加元素
</code></pre><hr>
<blockquote>
<p>数组初始化方法：<br>   NSArray <em>arr=[NSArray arrayWithObject:&lt;#(nonnull id)#&gt;]  传入一个对象<br>   NSArray </em>arr=[NSArray arrayWithObjects:&lt;#(nonnull id), …#&gt;, nil] 传入多个对象，注意：数组中的nil是结束符</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">案例：</div><div class="line">    Person *p=[Person new];</div><div class="line">    NSObject *obj=[NSObject new];</div><div class="line">    NSArray *array=[NSArray arrayWithObjects:@&quot;lnj&quot;,p,obj, nil];</div><div class="line">    说明：可以把其他类型转换为对象，存放到数组中。</div><div class="line">    [array count]:获取数组长度</div><div class="line">    [array lastObject]:获取数组最后一个元素</div><div class="line">    [array firstObject]:获取数组第一个元素</div><div class="line">    [array objectAtIndex:&lt;#(NSUInteger)#&gt;]:获取指定位置的元素</div><div class="line">    [array containsObject:&lt;#(nonnull id)#&gt;]：是否包含某一个元素</div><div class="line">简写方法：</div><div class="line">NSArray *arr=@[@&quot;lnj&quot;,@&quot;lmj&quot;];</div><div class="line">arr[0];</div><div class="line">1.1遍历数组</div><div class="line">NSArray *arr=@[@&quot;lnj&quot;,@&quot;lmj&quot;];</div><div class="line">for (NSObject *val in arr) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,val);</div><div class="line">&#125;</div><div class="line">迭代器遍历</div><div class="line">[arr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        //obj：当前对象，idx：当前索引，stop：控制什么时候停止，可以赋值YES则停止遍历</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<h2 id="调用数组保存的对象中的方法"><a href="#调用数组保存的对象中的方法" class="headerlink" title="调用数组保存的对象中的方法"></a>调用数组保存的对象中的方法</h2><hr>
<pre><code>方式一：遍历数组，取出对象，然后通过对象调用方法
方式二：
调用show方法
[arr makeObjectsPerformSelector:@selector(show)];
传递参数：
[arr makeObjectsPerformSelector:&lt;#(nonnull SEL)#&gt; withObject:&lt;#(nullable id)#&gt;]
1.3：数组排序
[arr sortedArrayUsingSelector:@selector(compare:)];
排序后，返回一个新数组(默认conpare：是升序排序)
想使用compare：进行排序必须是Foundation中的对象，不能是自定义对象(例如person)
</code></pre><hr>
<blockquote>
<p>如果想对非Foundation中的对象进行排序，则可以使用下面方法，如下代码就是把person的age按照升序排序(默认就是按照升序排序)<br>NSArray <em>new=[arr sorted ArrayWithOptions:NSSortStableusingComparator:^NSComparisonResult(Person </em>obj1,Person *obj2)]{<br>    return obj1.age&gt;obj2.age;//改成小于就是降序排序<br>}];</p>
</blockquote>
<h2 id="数组和字符串转换"><a href="#数组和字符串转换" class="headerlink" title="数组和字符串转换"></a>数组和字符串转换</h2><blockquote>
<p>[arr componentsJoinedByString:@”-“]; 把arr每个元素遍历出来并用-链接成字符串返回<br>[str componentsSeparatedByString:@”<strong>“];：按照</strong>把字符串分割成数组并返回</p>
</blockquote>
<h2 id="数组读写"><a href="#数组读写" class="headerlink" title="数组读写"></a>数组读写</h2><hr>
<pre><code>此方法只能写入Foundation中的对象
[arr writeToFile:&lt;#(nonnull NSString *)#&gt; atomically:&lt;#(BOOL)#&gt;]
写入文件，参数一：是路径，参数二是否在写入成功的时候才生成文件
此方法是生成xml文件，一般会将xml文件的扩展名保存为plist
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">读取文件到数组：</div><div class="line">[NSArray arrayWithContentsOfFile:&lt;#(nonnull NSString *)#&gt;]//绝地址</div><div class="line">[NSArray arrayWithContentsOfURL:&lt;#(nonnull NSURL *)#&gt;]//url</div></pre></td></tr></table></figure>
<h1 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h1><blockquote>
<p>注意：不可以通过@[]来创建NSMutableArray数组，因为创建出来的是不可变数组。</p>
</blockquote>
<hr>
<pre><code>是NSArray的子类，是可变的，可以添加修改删除元素
[arr addObject:@&quot;lnj&quot;];//此方法也可以直接添加一个数组进去，但是不推荐
将指定数组中的元素都取出来，放到arr中(注意不是把整个数组放进去)
[arr addObjectsFromArray:@[@&quot;lnj&quot;,@&quot;lmj&quot;]];
插入元素：
指定位置插入元素
[arr insertObject:&lt;#(nonnull id)#&gt; atIndex:&lt;#(NSUInteger)#&gt;]
指定一个元素，指定数组需要插入的位置，和插入多少个
[arr insertObjects:&lt;#(nonnull NSArray *)#&gt; atIndexes:&lt;#(nonnull NSIndexSet *)#&gt;]
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">案例：</div><div class="line">    NSMutableArray *arr=[NSMutableArray array];</div><div class="line">    NSRange range=NSMakeRange(2, 2);//头一个2(索引)是插入的位置，第二个2指的是插入个数，如果下面不足2个会报错</div><div class="line">    NSIndexSet *set=[NSIndexSet indexSetWithIndexesInRange:range];</div><div class="line">    [arr insertObjects:@[@&quot;a&quot;,@&quot;b&quot;] atIndexes:set];</div><div class="line"></div><div class="line">删除元素：</div><div class="line">[arr removeObjectAtIndex:1]; 删除指定位置的元素</div><div class="line">[arr removeAllObjects] 清空数组</div><div class="line">[arr removeLastObject]:删除最后一个元素</div><div class="line">[arr removeObject:@&quot;a&quot;]; 删除指定元素</div><div class="line"></div><div class="line">替换元素：</div><div class="line">[arr replaceObjectAtIndex:1 withObject:@&quot;a&quot;]; 用替换数组索引为1的元素</div><div class="line">arr[1]=@&quot;a&quot;; 等效</div><div class="line">获取元素：</div><div class="line">[arr objectAtIndex:1]:获取索引1处的元素</div><div class="line">arr[1]:等效</div></pre></td></tr></table></figure>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><hr>
<pre><code>字典中保存数据是无序的
基本使用
NSDictionary *dict=[NSDictionary dictionaryWithObject:@&quot;lnj&quot; forKey:@&quot;name&quot;];
NSString *name=[dict objectForKey:@&quot;name&quot;];
多个key和value：
NSDictionary *dict=[NSDictionary dictionaryWithObjects:@[@&quot;lnj&quot;,@&quot;30&quot;,@&quot;1.75&quot;] forKeys:@[@&quot;name&quot;,@&quot;age&quot;,@&quot;height&quot;]];
简单方式：
NSDictionary *dict1=@{@&quot;name&quot;:@&quot;lnj&quot;};
dict1[@&quot;name&quot;];
</code></pre><hr>
<h2 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">获取键值对的个数:[dict count];</div><div class="line">获取所有key:[dict allKeys];</div><div class="line">for (NSString *obj in dict) &#123;</div><div class="line">        //obj就是key</div><div class="line">        //dict[obj]获取value</div><div class="line">&#125;</div><div class="line">其他方式：</div><div class="line">[dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><hr>
<pre><code>写入文件：[dict writeToFile:&lt;#(nonnull NSString *)#&gt; atomically:&lt;#(BOOL)#&gt;]
生成也是xml文件，扩展名最好也修改为plist
读取文件
[NSDictionary dictionaryWithContentsOfURL:&lt;#(nonnull NSURL *)#&gt;]
[NSDictionary dictionaryWithContentsOfFile:&lt;#(nonnull NSString *)#&gt;]
</code></pre><hr>
<h1 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h1><hr>
<pre><code>//创建空字典
NSMutableDictionary *dict=[NSMutableDictionary dictionary];
添加：
[dict setObject:&lt;#(nonnull id)#&gt; forKey:&lt;#(nonnull id&lt;NSCopying&gt;)#&gt;]
会将传入字典中所有键值对取出来，依次放入新字典中
[dict setValuesForKeysWithDictionary:@{@&quot;age&quot;:@&quot;30&quot;,@&quot;height&quot;:@&quot;1.75&quot;}];
删除：
[dict removeObjectForKey:&lt;#(nonnull id)#&gt;]
[dict removeObjectsForKeys:&lt;#(nonnull NSArray *)#&gt;]
[dict removeAllObjects]
修改：
[dict setObject:&lt;#(nonnull id)#&gt; forKey:&lt;#(nonnull id&lt;NSCopying&gt;)#&gt;]
dict[@&quot;name&quot;]=@&quot;lmj&quot;;
</code></pre><hr>
<blockquote>
<p>注意：不可以通过@{}创建可变字典<br>如果是不可变字典，那么key不能相同，相同key后面的key值不会被保存<br>如果是可变字典，相同key，后面key会覆盖前面key的value</p>
</blockquote>
<h1 id="常用结构体"><a href="#常用结构体" class="headerlink" title="常用结构体"></a>常用结构体</h1><hr>
<pre><code>NSPoint和CGPoint：二维平面的一个点
    可使用CGMakePoint和NSMakePoint函数创建CGPoint
    CGPoint point=NSMakePoint(10,20)；
NSSize和CGSize:保存尺寸
    创建结构体都是NSMakexxx
NSRect和CGRect：保存坐标和尺寸,其实就是上两个的结合体
    CGRect rect=NSMakeRect(10,20,100,50);先是坐标，后是尺寸
苹果推荐使用CG开头的

注意：这前后两个都是分别等效的(别名而已)
</code></pre><hr>
<h1 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h1><hr>
<pre><code>将基本数据类型转化为对象类型，这样数组和字典就能存储了
NSNumber *number=[NSNumber numberWithBool:&lt;#(BOOL)#&gt;]
NSNumber *number=[NSNumber numberWithInt:&lt;#(int)#&gt;]
还有很多numberWithXXX
将对象转换为基本数据类型
double temp=[number doubleValue];
基本数据类型转对象类型简写：
NSNumber *temp=@(age);
注意：如果传入的是变量，必须在@后面写上(),如果传入常量，那么@()可省略
</code></pre><hr>
<h1 id="NSValue"><a href="#NSValue" class="headerlink" title="NSValue"></a>NSValue</h1><blockquote>
<p>可以包装任意类型（包装过后就可以存入数组，字典了）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">基本案例：</div><div class="line">    CGPoint point =NSMakePoint(10, 20);</div><div class="line">    NSValue *value=[NSValue valueWithPoint:point];</div><div class="line">    NSArray *arr=@[value];</div><div class="line">包装自定义结构体</div><div class="line"> typedef struct&#123;</div><div class="line">        int gae;</div><div class="line">        char *name;</div><div class="line">        double height;</div><div class="line">    &#125;Person;</div><div class="line">    Person p=&#123;30,&quot;lnj&quot;,1.75&#125;;</div><div class="line">    //valueWithBytes：接受一个指针，需要传递需要包装的结构体的变量的地址</div><div class="line">    //objCType:需要传递需要包装的数据类型</div><div class="line">    NSValue *value=[NSValue valueWithBytes:&amp;p objCType:@encode(Person)];</div><div class="line">    NSArray *arr=@[value];</div><div class="line">     //取出值</div><div class="line">    Person res;</div><div class="line">    [value getValue:&amp;res];</div></pre></td></tr></table></figure>
<blockquote>
<p>说明：之所以要传入一个res参数，是因为getValue方法没有返回值，信息存储在传入的参数的地址里面，故而可以通过该地址取出相关信息。</p>
</blockquote>
<h1 id="NSDate"><a href="#NSDate" class="headerlink" title="NSDate"></a>NSDate</h1><hr>
<pre><code>时间对象
 //只要创建，则now就会存储当前时间
    NSDate *now=[NSDate date];
    //在now基础上追加多少秒
    NSDate *date=[now dateByAddingTimeInterval:10]//追加10秒,因为是不可变的，所以返回新的
获取当前时区的时间（因为默认获取的可能不是当前时区的时间）：
int main(int argc, const char * argv[]) {
    NSDate *now=[NSDate date];
    //获取当前所处时区
    NSTimeZone *zone=[NSTimeZone systemTimeZone];
    //获取当前时区和指定时间的时间差
    NSInteger seconds=[zone secondsFromGMTForDate:now];
    NSDate *date=[now dateByAddingTimeInterval:seconds];
    return 0;
}
</code></pre><hr>
<h2 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">案例：获取xxx年xxx月...这种格式化后的时间</div><div class="line">    NSDate *now=[NSDate date];</div><div class="line">    //创建一个时间格式化的对象</div><div class="line">    NSDateFormatter *formatter=[[NSDateFormatter alloc]init];</div><div class="line">    //利用时间格式化对象对时间进行格式化</div><div class="line">    NSString *res=[formatter stringFromDate:now];</div><div class="line">上面案例是只能生成固定格式时间，下面是类似自定义格式：</div><div class="line">    NSDate *now=[NSDate date];</div><div class="line">    NSDateFormatter *formatter=[[NSDateFormatter alloc]init];</div><div class="line">    formatter.dateFormat=@&quot;yyyy年MM月dd日HH时mm分ss秒&quot;;</div><div class="line">    NSString *res=[formatter stringFromDate:now];</div><div class="line">字符串转时间：</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    NSString *time=@&quot;2015-06-29 09:05:26&quot;;</div><div class="line">    NSDateFormatter *formatter=[[NSDateFormatter alloc]init];</div><div class="line">    formatter.dateFormat=@&quot;yyyy年MM月dd日HH时mm分ss秒&quot;;</div><div class="line">    NSDate *date=[formatter dateFromString:time];</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="NSCalender"><a href="#NSCalender" class="headerlink" title="NSCalender"></a>NSCalender</h1><blockquote>
<p>NSCalendar *cal=[NSCalendar currentCalendar];<br>说明：这个是单例的，不论获取多少次，都是同一个</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">案例：通过日历，获取传入时间对象的对应信息</div><div class="line">     NSDate *now=[NSDate date];</div><div class="line">    NSCalendar *cal=[NSCalendar currentCalendar];</div><div class="line">    NSDateComponents *cmps=[cal components:NSCalendarUnitYear fromDate:now];//获取年</div><div class="line">如果想获取多个：</div><div class="line">    int main(int argc, const char * argv[]) &#123;</div><div class="line">    NSDate *now=[NSDate date];</div><div class="line">    NSCalendar *cal=[NSCalendar currentCalendar];</div><div class="line">    //一个参数是一个枚举，可以通过|连接多个枚举值</div><div class="line">    NSCalendarUnit type=NSCalendarUnitYear|NSCalendarUnitDay;</div><div class="line">    NSDateComponents *cmps=[cal components:type fromDate:now];</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">比较两个时间之间的差值：</div><div class="line">过去的一个时间</div><div class="line">NSString *time=@&quot;2015-06-29 09:05:26&quot;;</div><div class="line">NSDateFormatter *formatter=[[NSDateFormatter alloc]init];</div><div class="line">formatter.dateFormat=@&quot;yyyy年MM月dd日HH时mm分ss秒&quot;;</div><div class="line"> NSDate *date=[formatter dateFromString:time];</div><div class="line">当前时间</div><div class="line">NSDate *now=[NSDate now];</div><div class="line">比较时间</div><div class="line">NSCalendar *cal=[NSCalendar currentCalendar];</div><div class="line">NSCalendarUnit type=NSCalendarUnitYear|NSCalendarUnitDay;</div><div class="line">NSDateComponents *cmps=[cal components:type fromDate:time toDate:now options:0];//0是按照系统默认处理</div></pre></td></tr></table></figure>
<h1 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h1><hr>
<pre><code>管理文件：也是单例模式
NSFileManager *manager=[NSFileManager defaultManager];
判断一个文件或者文件夹是否存在
BOOL flag=[manager fileExistsAtPath:@&quot;绝对路径&quot;];
判断一个文件是否存在，并且判断是否是一个文件夹
BOOL dir=NO;
BOOL flag=[manager fileExistsAtPath:@&quot;绝对路径&quot; isDirectory:&amp;dir];
说明：第二个参数是用来保存判断结果的，如果是一个目录，那么会赋值为YES，如果不是就赋值为NO
</code></pre><hr>
<h2 id="获取文件或文件夹的属性"><a href="#获取文件或文件夹的属性" class="headerlink" title="获取文件或文件夹的属性"></a>获取文件或文件夹的属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSFileManager *manager=[NSFileManager defaultManager];</div><div class="line">NSDictionary *dict=[manager attributesOfItemAtPath:@&quot;路径&quot; error:nil];</div></pre></td></tr></table></figure>
<h2 id="获取文件夹所有文件"><a href="#获取文件夹所有文件" class="headerlink" title="获取文件夹所有文件"></a>获取文件夹所有文件</h2><hr>
<pre><code>[manager contentsOfDirectoryAtPath:&lt;#(nonnull NSString *)#&gt; error:nil] 返回值是数组
弊端：只能获取当前文件下的文件，不能获取子文件夹下面的文件

获取包括子文件夹在内的所有文件：
[manager subpathsAtPath:&lt;#(nonnull NSString *)#&gt;]
[manager subpathsOfDirectoryAtPath:&lt;#(nonnull NSString *)#&gt; error:&lt;#(NSError * _Nullable __autoreleasing * _Nullable)#&gt;]

拷贝文件：
[manager copyItemAtPath:&lt;#(nonnull NSString *)#&gt; toPath:&lt;#(nonnull NSString *)#&gt; error:&lt;#(NSError * _Nullable __autoreleasing * _Nullable)#&gt;]
移动文件：
[manager moveItemAtPath:&lt;#(nonnull NSString *)#&gt; toPath:&lt;#(nonnull NSString *)#&gt; error:&lt;#(NSError * _Nullable __autoreleasing * _Nullable)#&gt;]
删除文件：
[manager removeItemAtPath:&lt;#(nonnull NSString *)#&gt; error:&lt;#(NSError * _Nullable __autoreleasing * _Nullable)#&gt;]
创建文件夹：
[manager createDirectoryAtPath:&lt;#(nonnull NSString *)#&gt; withIntermediateDirectories:&lt;#(BOOL)#&gt; attributes:&lt;#(nullable NSDictionary&lt;NSString *,id&gt; *)#&gt; error:&lt;#(NSError * _Nullable __autoreleasing * _Nullable)#&gt;]
</code></pre><hr>
<blockquote>
<p>说明：createDirectoryAtPath：创建文件夹的位置<br>withIntermediateDirectories：如果值得文件中有一些文件夹不存在，是否自动创建不存在的文件夹，多级文件夹时候，前面文件夹不存在，是否自动创建(布尔值)<br>attributes：指定创建出来的文件夹的属性（可读，可写，可读写）</p>
</blockquote>
<hr>
<pre><code>创建文件夹：
[manager createFileAtPath:&lt;#(nonnull NSString *)#&gt; contents:&lt;#(nullable NSData *)#&gt; attributes:&lt;#(nullable NSDictionary&lt;NSString *,id&gt; *)#&gt;]
说明：
createFileAtPath;文件创建的路径
contents：文件内容
attributes：文件属性

注意：NSDate：二进制数据
</code></pre><hr>
<h1 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h1><hr>
<pre><code>利用源对象产生一个新的对象
copy:创建的是不可变副本(NSString,NSArray等)
mutableCopy：创建的是可变副本(NSMutableArray等)
实现对应协议(copy或mutableCopy)，然后实现copytWithZone/mutableCopyWithZone
oc中自带类几乎都实现了上面协议，可以直接使用（如果是自定义类型，需要自己实现）
 NSString *str=@&quot;lnj&quot;;
 NSMutableString *str1=[str mutableCopy];
 说明：
copy和mutableCopy也不是一定生成新对象，oc会进行优化，只要满足，新对象和老对象修改
都互不影响即可，如果copy和之前都是不可变对象，则这样没必要生成新对象了，这属于oc的自动优化。
浅拷贝：不会产生新的对象
深拷贝：会产生新的对象
</code></pre><hr>
<h2 id="copy和property"><a href="#copy和property" class="headerlink" title="copy和property"></a>copy和property</h2><blockquote>
<p>以后防止外面可以修改内部字符串，都是用下面写法<br>@property(nonatomic,copy)NSString *name;//不在使用以前的retain</p>
</blockquote>
<hr>
<pre><code>补充：Block_copy(myBlock);
使用该方法进行block拷贝，不会进行copy而是把block从栈中转移到堆内存中
这样可以避免，要使用的外界对象已经释放了。
</code></pre><hr>
<h2 id="自定义类实现copy"><a href="#自定义类实现copy" class="headerlink" title="自定义类实现copy"></a>自定义类实现copy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(id) copyWithZone:(NSZone *)zone&#123;</div><div class="line">    //创建一个新的对象</div><div class="line">    Person *p=[[[self class] allocWithZone:zone]init];</div><div class="line">    //设置当前对象的内容给新的对象</div><div class="line">    p.age=_age;</div><div class="line">    p.name=_name;</div><div class="line">    //返回新的对象</div><div class="line">    return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<pre><code>说明：如果是mutableCopy内部代码是一抹一样的
理论上子类会继承父类的copy，但是有可能子类有的属性父类没有，所以一般也要重写。
内部代码如下：
id obj=[super copyWithZone:zone];
[obj setHeight:_height];
return obj;
说明：已经实现的使用父类即可，没有的子类在加上就行
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Qiang" />
          <p class="site-author-name" itemprop="name">Qiang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
