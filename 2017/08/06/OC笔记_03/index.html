<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="autoreleasepool  ARC下用 @autoreleasepool {}主要还是为了避免内存峰值。  用@autoreleasepool是有用的。正常情况下，你创建的变量会在超出其作用域的时候被释放掉。  而如果你的函数写的很长，在你函数运行过程中出现很多中间变量，占据了大量的内存，怎么办？  用@autoreleasepool。在@autoreleasepool中创建的变量，会在@a">
<meta property="og:type" content="article">
<meta property="og:title" content="OC语言笔记_03">
<meta property="og:url" content="http://yoursite.com/2017/08/06/OC笔记_03/index.html">
<meta property="og:site_name" content="飞奔的小猿猴">
<meta property="og:description" content="autoreleasepool  ARC下用 @autoreleasepool {}主要还是为了避免内存峰值。  用@autoreleasepool是有用的。正常情况下，你创建的变量会在超出其作用域的时候被释放掉。  而如果你的函数写的很长，在你函数运行过程中出现很多中间变量，占据了大量的内存，怎么办？  用@autoreleasepool。在@autoreleasepool中创建的变量，会在@a">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-07-09T06:21:19.455Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OC语言笔记_03">
<meta name="twitter:description" content="autoreleasepool  ARC下用 @autoreleasepool {}主要还是为了避免内存峰值。  用@autoreleasepool是有用的。正常情况下，你创建的变量会在超出其作用域的时候被释放掉。  而如果你的函数写的很长，在你函数运行过程中出现很多中间变量，占据了大量的内存，怎么办？  用@autoreleasepool。在@autoreleasepool中创建的变量，会在@a">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/06/OC笔记_03/"/>





  <title>OC语言笔记_03 | 飞奔的小猿猴</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">飞奔的小猿猴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/OC笔记_03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞奔的小猿猴">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OC语言笔记_03</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T21:22:10+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Object-C/" itemprop="url" rel="index">
                    <span itemprop="name">Object C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h1><hr>
<pre><code> ARC下用 @autoreleasepool {}主要还是为了避免内存峰值。
 用@autoreleasepool是有用的。正常情况下，你创建的变量会在超出其作用域的时候被释放掉。
 而如果你的函数写的很长，在你函数运行过程中出现很多中间变量，占据了大量的内存，怎么办？
 用@autoreleasepool。在@autoreleasepool中创建的变量，会在@autoreleasepool结束的时候执行一次release，进行释放。
 其实@autoreleasepool就相当于一层作用域。
其他使用场景：写了子线程的时候。
</code></pre><hr>
<h1 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h1><hr>
<pre><code>是一个编译器特性，而不是运行时特性
不是其他语言的垃圾回收
    //强指针，默认情况下都是强指针
    __strong Person *p=[[Person alloc] init];
    //弱指针
    __weak Person *p=[[Person alloc] init];
注意：在arc模式下，只有没有(强指针)指向对象，则对象就会被回收。
可以通过p=nil实现回收。//单个对象的内存管理
在开发中不要使用弱指针保存刚刚创建的对象，不然刚创建就会被释放，而强指针，如果没有
直接使用nil，则会到作用域一般是大括号结尾处才销毁强指针，也就是释放对象。
</code></pre><hr>
<h2 id="对多个对象的内存管理"><a href="#对多个对象的内存管理" class="headerlink" title="对多个对象的内存管理"></a>对多个对象的内存管理</h2><hr>
<pre><code>arARC模式下，a对象想拥有b对象，那么就需要用一个强指针指向B对象
@property(nonatomic,strong)Dog *dog;
此时在person类中声明dog类对象，如果想强制a(person)对象拥有b(dog)对象
那么必须用strong修饰。这样在person没有被销毁的情况下，dog也不会被销毁
</code></pre><hr>
<blockquote>
<p>在使用的地方代码如下：<br>Dog *d=[Dog new];<br>p.dog=d;<br>注意点：assign是专门用于保存基本数据类型的，如果保存对象用weak。<br>总结：<br>ARC下@property参数<br>strong：用于oc对象，相当于mrc中的retain<br>weak：用于oc对象，相当于mrc中的assign<br>assign：用于基本数据类型，相当于mrc中的assign一样</p>
</blockquote>
<h1 id="category"><a href="#category" class="headerlink" title="category"></a>category</h1><blockquote>
<p>可以再原来类的基础上，为一个类扩充方法<br>一个庞大的类可以分模块开发<br>一个庞大的类可以由多个人来编写，利于团队合作</p>
</blockquote>
<h2 id="分类的格式"><a href="#分类的格式" class="headerlink" title="分类的格式"></a>分类的格式</h2><hr>
<pre><code>分类的声明：
@interface ClassName (CategoryName)
NewMethod;//在类别中添加方法
//不允许在类别中添加变量
@end
ClassName:需要给那个类扩充方法
CategoryName：分类的名称
分类的实现：
@implementtation ClassName(CategoryName)
NewMethod
@end
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">例子：</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &quot;Person+ZQ.h&quot;//需要导入对应头文件</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    Person *p=[[Person alloc] init];</div><div class="line">    p.age=30;</div><div class="line">    [p say];</div><div class="line">    [p play];//扩充的方法</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">_______________</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">@property(nonatomic,assign) int age;</div><div class="line">-(void)say;</div><div class="line">@end</div><div class="line">_______________</div><div class="line">#import &quot;Person.h&quot;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">-(void)say&#123;</div><div class="line">    NSLog(@&quot;%d&quot;,_age);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">_______________</div><div class="line">#import &quot;Person.h&quot;</div><div class="line"></div><div class="line">@interface Person (ZQ)</div><div class="line">-(void)play;</div><div class="line">@end</div><div class="line">_______________</div><div class="line">#import &quot;Person+ZQ.h&quot;</div><div class="line"></div><div class="line">@implementation Person (ZQ)</div><div class="line">-(void)play&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">_______________</div></pre></td></tr></table></figure>
<hr>
<pre><code>创建category文件，直接选中oc文件，然后输入category名称，选择category，然后选择要扩充的类
注意事项：
只能添加方法，不能添加属性
分类中@property,只会生成setter/getter方法的声明，不会生成实现以及私有的成员变量。
可以在分类中访问原有类中.h的属性（.m的属性是私有的，其他类不能访问）
如果分类中有和原有类同名的方法，会调用分类中的方法
如果多个分类都有和原有类同名方法，会执行编译器最后编译的分类的方法（结果不一定）
</code></pre><hr>
<h2 id="匿名分类（类扩展）"><a href="#匿名分类（类扩展）" class="headerlink" title="匿名分类（类扩展）"></a>匿名分类（类扩展）</h2><hr>
<pre><code>可以为某个类扩充一些私有的成员变量和方法
写在.m文件中，英文名是Class Extension
以前写私有变量和方法，就是在.h文件中不声明变量和方法（因为声明的都是公开的变量或方法）
然后在.m文件直接写方法实现，和定义变量，才能生成私有的方法或变量，但是通过匿名分类
可以在.m文件中直接书写私有变量和方法
</code></pre><hr>
<hr>
<pre><code>下面代码就是在person的.m文件中
#import &quot;Person.h&quot;
@interface Person(){
    int _num;
}
-(void) show;
@end//这个地方就是匿名分类
————————————————

@implementation Person
-(void)say{
    NSLog(@&quot;%d&quot;,_age);
}
@end
补充：取出指定位置的字符[str characterAtIndex:1],取出1位置的字符
使用场景：比如说给NSString扩展方法
</code></pre><hr>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><blockquote>
<p>比较特殊的数据类型<br>作用：保存一段代码，可以再恰当的时间再取出调用，功能类似函数和方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">案例：</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">void printRose()&#123;</div><div class="line">    printf(&quot;   &#123;@&#125; \n&quot;);</div><div class="line">    printf(&quot;   \\|/  \n&quot;);</div><div class="line">    printf(&quot;    |  \n&quot;);</div><div class="line">&#125;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    /*</div><div class="line">     void代表指向的函数没有返回值</div><div class="line">     ()代表指向的函数没有形参</div><div class="line">     (*roseP)代表roseP是一个指向函数的指针</div><div class="line">     */</div><div class="line">    void(*roseP)();</div><div class="line">    roseP=printRose;</div><div class="line">    roseP();</div><div class="line">    //定义一个block变量，block和函数一样，可以没有返回值也没有形参</div><div class="line">    void(^roseBlock)();</div><div class="line">    /*</div><div class="line">     void代表block将来保存的代码没有返回值</div><div class="line">     ()代表block将来保存的代码没有形参</div><div class="line">     (^roseBlock)是一个block变量，可以用于保存一段block代码</div><div class="line">     */</div><div class="line">    roseBlock=^()&#123;//没有参数可以省略()</div><div class="line">        printf(&quot;   &#123;@&#125; \n&quot;);</div><div class="line">        printf(&quot;   \\|/  \n&quot;);</div><div class="line">        printf(&quot;    |  \n&quot;);</div><div class="line">    &#125;;</div><div class="line">    roseBlock();</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">此案例对比了函数指针和block的使用。</div></pre></td></tr></table></figure>
<hr>
<pre><code>有参数案例：
 void(^roseBlock)(int);
    roseBlock=^(int num){
        for (int a=0; a&lt;num; a++) {
            printf(&quot;   {@} \n&quot;);
            printf(&quot;   \\|/  \n&quot;);
            printf(&quot;    |  \n&quot;);
        }
    };
roseBlock(10);
也可以定义同时初始化，直接把下面一部分踢到上面即可。
</code></pre><hr>
<h2 id="block和typedef"><a href="#block和typedef" class="headerlink" title="block和typedef"></a>block和typedef</h2><hr>
<pre><code>利用typedef给block起别名，和指向函数的指针一样，block变量的名称就是别名
typedef int (^calcAdd)(int ,int);
int main(int argc, const char * argv[]) {
    calcAdd add=^(int v1,int v2){
        return v1+v2;
    };
    NSLog(@&quot;%d&quot;,add(1,2));
    return 0;
}
说明：这是以后的推荐写法，此时calcAdd就是一个数据类型了。
</code></pre><hr>
<h2 id="block使用场景"><a href="#block使用场景" class="headerlink" title="block使用场景"></a>block使用场景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">当发现代码的前面和后面都一样的时候，就可以使用block了</div><div class="line">void geToWork(void(^workBlock)())&#123;</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    workBlock();</div><div class="line">//因为block是数据类型，所以可以当做参数传递。</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<pre><code>注意事项：
在block中可以访问外部变量
blocck中可以和外界同名的变量，至于使用，也是就近原则
默认情况下，不可以在block修改外界的变量，因为block中访问外界变量时候，block会将该变量
copy一份到堆内存中（不是同一个）。
如果想在block中修改外界的变量的值，必须在外界变量前面加上__block。
如果加上__block其实就是地址传递，所以可以修改外界变量的值（不加的话就是值传递）。
block可以存在堆或栈，默认是存储在栈中，如果对block是进行一个copy操作，block会转移到堆中。
</code></pre><hr>
<h1 id="协议protocol"><a href="#协议protocol" class="headerlink" title="协议protocol"></a>协议protocol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">在java中类似接口</div><div class="line">protocol可以声明一些必须实现的方法和选择实现的方法，这个和java不同</div><div class="line">也就是说protocol是由一系列方法声明组成</div><div class="line">定义：</div><div class="line">@protocol 协议名称</div><div class="line">//方法声明列表</div><div class="line">@end</div><div class="line">使用</div><div class="line">@interface 类名：父类&lt;协议名称1，协议名称2&gt;</div><div class="line">@end</div><div class="line">案例：</div><div class="line">文件名： PersonInterface.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@protocol PersonInterface &lt;NSObject&gt;</div><div class="line">-(void)show;</div><div class="line">@end</div><div class="line">文件名：Person.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;PersonInterface.h&quot;</div><div class="line">@interface Person : NSObject&lt;PersonInterface&gt;</div><div class="line">@end</div><div class="line">文件名：person.m</div><div class="line">#import &quot;Person.h&quot;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">-(void)show&#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">文件名：main.m</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;Person.h&quot;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    Person *p=[[Person alloc] init];</div><div class="line">    [p show];</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<pre><code>注意点：
协议只能声明方法，不能声明属性
子类也会拥有父类协议的方法声明
协议的协议又可以租售其他协议，只要遵守了其他协议，那么这个协议就会包含其他协议的声明
@required和@optional关键字：加在方法的上面
@required：这个方法必须被实现（默认）
@optional：这个方法不一定被实现
</code></pre><hr>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><hr>
<pre><code>Person *p=[Person new];
//可以将协议卸载数据类型的右边，明确的标注如果想给该变量赋值，那么该对象必须遵守某个协议
//如果没有实现方法，会报警告
Wife&lt;WifeConditon&gt; *w=[Wife new];
p.wife=w;
_______________
@property(nonatomic,strong)Wife&lt;WifeConditon&gt; *wife;
注意：虽然在接受某一个对象，对这个对象类型进行了限定（限定它必须实现某个协议），但是
并不意味就真正实现了该方法，如果调用对象协议方法时候要进行一次验证。
if([self.wife respondsToSelector:@selector(cooking)]){
        [self.wife.cooking];
}
</code></pre><hr>
<h1 id="oc字符串"><a href="#oc字符串" class="headerlink" title="oc字符串"></a>oc字符串</h1><hr>
<pre><code>//如何创建字符串对象
     //1.通过字符串常量创建,存储在常量区中，此种方式创建多个字符串对象（字符串常量一致），指向同一块内存空间
    NSString *str1=@&quot;lnj&quot;;
    //2.通过alloc init创建，存储在堆中，在mac平台上(其他平台不一定)，会自动优化(字符串常量一致，会指向同一块内存空间)
    NSString *str2=[[NSString alloc] initWithFormat:@&quot;lnj&quot;];
    //3.通过类工厂方法/string WithFormat，存储在堆中，在mac平台上(其他平台(ios)不一定)，会自动优化(字符串常量一致，会指向同一块内存空间)
    //内部就是封装了[NSString alloc] init
    NSString *str3=[NSString stringWithFormat:@&quot;lnj&quot;];
</code></pre><hr>
<hr>
<pre><code>注意：一般情况下，只要通过alloc或者通过类工厂方法创建的对象，每次都会在堆内存中开辟一块
内存空间，但是如果是通过alloc的initWithString方法除外，因为这个方法是通过copy返回一个
字符串对象给我们。
而copy分为浅拷贝和深拷贝，深拷贝会创建一个新的对象，如果是浅拷贝不会创建一个新的对象，而是直接返回被拷贝对象的地址给我们。
而initWithString正好是浅拷贝，所以不论是什么平台，什么编译器都会指向同一块存储空间。
</code></pre><hr>
<h2 id="字符串的读写"><a href="#字符串的读写" class="headerlink" title="字符串的读写"></a>字符串的读写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">读取文件的内容到字符</div><div class="line">  NSString *info=[NSString stringWithContentsOfFile:&lt;#(nonnull NSString *)#&gt; encoding:&lt;#(NSStringEncoding)#&gt; error:&lt;#(NSError * _Nullable __autoreleasing * _Nullable)#&gt;]</div></pre></td></tr></table></figure>
<hr>
<pre><code>参数一：是文件的绝对路径
参数二：NSStringEncoding没有*通过翻看源码可知就是enum枚举类型
参数三：是读取出错，信息保存在这，成功的时候是nil,此时是指针的指针，所有参数传递如下面代码，是指针的地址
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    NSError *error=nil;</div><div class="line">    NSString *info=[NSString stringWithContentsOfFile:@&quot;/Users/tjsmc/Desktop/mac快捷键.txt&quot; encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">    if (error==nil) &#123;</div><div class="line">      NSLog(@&quot;%@&quot;,info);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果文件不存在等错误，则error直接打印是很多无用信息，需要通过[error localizedDescription]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">写入文本：</div><div class="line">案例：</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    NSString *info=@&quot;这个是生成的文本&quot;;</div><div class="line">    //atomically:如果是yes，则字符串写入文件过程中没有写入完毕，不生成文件</div><div class="line">    //no:则字符串写入文件过程中没有写入完毕，生成文件</div><div class="line">    BOOL flag=[info writeToFile:@&quot;/Users/tjsmc/Desktop/abc.txt &quot; atomically:YES encoding:NSUTF8StringEncoding error:nil];</div><div class="line">    NSLog(@&quot;%i&quot;,flag);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">开发中常用的读写字符串</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    //1.创建url:注意如果访问的是本级文件，地址192.168.0.112可省略</div><div class="line">    NSString *path=@&quot;file://192.168.0.112/Users/tjsmc/Desktop/1.txt&quot;;</div><div class="line">   // NSString *path=@&quot;http://www.baidu.com&quot;;</div><div class="line">    NSURL *url=[NSURL URLWithString:path];</div><div class="line">    //2.根据url加载文件中的字符串</div><div class="line">    NSError *error=nil;</div><div class="line">    NSString *str=[NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">    NSLog(@&quot;%@&quot;,str);</div><div class="line">    NSLog(@&quot;%@&quot;,[error localizedDescription]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<pre><code>其他方式：
注意：在开发中，读取本机资源，如果直接使用url如果路径包中文，会读取不出来文件内容
但是如果使用fileURLWithPath就可以系统内部进行处理，依然可以读取出来。
如果非要使用url中文直接读取文件
需要：path=[path stringByAddingPercentEscapesUsingEncoding];
</code></pre><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    //1.创建url</div><div class="line">    NSString *path=@&quot;/Users/tjsmc/Desktop/1.txt&quot;;</div><div class="line">    //注意：使用fileURLWithPath方法的时候，系统会自动加上消息头，如果path前面加上file://会报错</div><div class="line">    NSURL *url=[NSURL fileURLWithPath:path];</div><div class="line">    //2.根据url加载文件中的字符串</div><div class="line">    NSError *error=nil;</div><div class="line">    NSString *str=[NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">    NSLog(@&quot;%@&quot;,str);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">_______________</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">   NSString *str=@&quot;呵呵呵撒很骄傲和解放初步额e&quot;;</div><div class="line">    NSURL *url=[NSURL URLWithString:@&quot;/Users/tjsmc/Desktop/1.txt&quot;];</div><div class="line">    BOOL flag=[str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil];</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">注意：多次写入文件，后一次会覆盖前一次的</div></pre></td></tr></table></figure>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">isEqualToString:比较两个字符串内容是否相同</div><div class="line"> NSString *str1=@&quot;lnj&quot;;</div><div class="line">    NSString *str2=@&quot;lnj&quot;;</div><div class="line">    BOOL flag=[str1 isEqualToString:str2];</div><div class="line">    NSLog(@&quot;%i&quot;,flag);//1</div><div class="line">注意：str1==str2比较的是字符串的地址</div><div class="line">比较字符串大小</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">   NSString *str1=@&quot;lnj&quot;;</div><div class="line">    NSString *str2=@&quot;lnj&quot;;</div><div class="line">    switch ([str1 compare:str2]) &#123;</div><div class="line">        case NSOrderedAscending://前面小于后面的</div><div class="line">            </div><div class="line">            break;</div><div class="line">        case NSOrderedSame://前面等于后面的</div><div class="line">            </div><div class="line">            break;</div><div class="line">        case NSOrderedDescending://前面大于后面的</div><div class="line">            </div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">忽略大小写进行比较：[str1 caseInsensitiveCompare:str2]</div></pre></td></tr></table></figure>
<h2 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h2><hr>
<pre><code>hasPrefix:字符串是否已什么开头
    NSString *str=@&quot;http://www.baidu.com&quot;;
    BOOL falg= [str hasPrefix:@&quot;http&quot;];
    NSLog(@&quot;%i&quot;,falg);//1

 hasSuffix:是否是什么结尾
 rangeOfString：是否包含什么,返回值类型NSRange，其实就是一个结构体（是两个lu类型）一个是起始位置，一个是长度
 如果没有找到需要查找到字符串，返回的range的length=0,location=NSNotFound
</code></pre><hr>
<h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> 案例：</div><div class="line"> int main(int argc, const char * argv[]) &#123;</div><div class="line">  NSString *str=@&quot;&lt;head&gt;小码哥&lt;/head&gt;&quot;;</div><div class="line">    //NSRange;位置、长度</div><div class="line">//    NSRange range=&#123;6,3&#125;;</div><div class="line">    //只要是oc提供的结构体，一般都可以使用NSMakexxx来创建</div><div class="line">//    NSRange range=NSMakeRange(6, 3);//开发中常用</div><div class="line">    //但是上面是写死的，实际开发中，需要动态获取</div><div class="line">    NSUInteger location=[str rangeOfString:@&quot;&gt;&quot;].location+1;//获取第一个&gt;位置</div><div class="line">    NSUInteger length=[str rangeOfString:@&quot;&lt;&quot; options:NSBackwardsSearch].location-location;//从后往前找&lt;</div><div class="line">    NSRange range;</div><div class="line">    range.location=location;</div><div class="line">    range.length=length;</div><div class="line">    NSString *new=[str substringWithRange:range];</div><div class="line">    NSLog(@&quot;%@&quot;,new);//小码哥</div><div class="line">    //注意：生成新字符串，以前字符串不变</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">案例：</div><div class="line"> //从什么地方开始截取，一直截取到最后</div><div class="line">[str substringFromIndex:str1];</div><div class="line">//从开头开始，一直截取到什么位置</div><div class="line">[str substringToIndex:st1];</div></pre></td></tr></table></figure>
<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">  NSString *str=@&quot;&lt;head&gt;小码哥&lt;/head&gt;&quot;;</div><div class="line">    NSString *new=[str stringByReplacingOccurrencesOfString:@&quot;小码哥&quot; withString:@&quot;强哥&quot;];</div><div class="line">    NSLog(@&quot;%@&quot;,new);</div><div class="line">    //注意：此方法可以通过替换的方式去除空格</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">去除首尾的空格：</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">  NSString *str=@&quot;   &lt;head&gt;小码哥&lt;/head&gt;&quot;;</div><div class="line">    NSCharacterSet *set=[NSCharacterSet whitespaceCharacterSet];</div><div class="line">    NSString *new=[str stringByTrimmingCharactersInSet:set];</div><div class="line">    NSLog(@&quot;%@&quot;,new);</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line">去除首尾的大写：</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">  NSString *str=@&quot;   &lt;head&gt;小码哥&lt;/head&gt;&quot;;</div><div class="line">    NSCharacterSet *set=[NSCharacterSet uppercaseLetterCharacterSet];//此处修改还可以去除小写等等</div><div class="line">    NSString *new=[str stringByTrimmingCharactersInSet:set];</div><div class="line">    NSLog(@&quot;%@&quot;,new);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="字符串和路径"><a href="#字符串和路径" class="headerlink" title="字符串和路径"></a>字符串和路径</h2><hr>
<pre><code>isAbsolutePath：判断是否是绝对路径，本质就是判断字符串是否以/开头
int main(int argc, const char * argv[]) {
  NSString *str=@&quot;/Users/tjsmc/Desktop/1.txt &quot;;
    BOOL flag=[ str isAbsolutePath];
    NSLog(@&quot;%i&quot;,flag);//1
       return 0;
}
获取文件路径中的最后一个目录：[str lastPathComponent]
删除文件路径中的最后一个目录：[str stringByDeletingLastPathComponent]
给文件路径添加一个目录：[str stringByAppendingPathComponent:@&quot;abc&quot;]
获取路径中文件的扩展名：[str pathExtension]
删除路径中文件的扩展名：[str stringByDeletingPathExtension]
给文件路径添加一个扩展名：[str stringByAppendingPathExtension:@&quot;jpg&quot;]
</code></pre><hr>
<h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><blockquote>
<p>字符串转小写:[str lowercaseString]<br>字符串转大写：[str uppercaseString]<br>字符串首字母转大写：[str capitalizedString]</p>
</blockquote>
<h3 id="字符串和基本数据类型的转换"><a href="#字符串和基本数据类型的转换" class="headerlink" title="字符串和基本数据类型的转换"></a>字符串和基本数据类型的转换</h3><hr>
<pre><code>字符串转数字：
    NSString *str1=@&quot;110&quot;;
    int v1=[str1 intValue];
c语言字符串和oc字符串之间的转换
char *cStr=&quot;lnj&quot;;
NSString *ocStr=[NSString stringWithUTF8String:cStr];
_______________
 NSString *ocStr=@&quot;lnj&quot;;
char *cStr=[ocStr UTF8String];
</code></pre><hr>
<h1 id="NSMutableString-是NSString的子类，是可变字符串"><a href="#NSMutableString-是NSString的子类，是可变字符串" class="headerlink" title="NSMutableString:是NSString的子类，是可变字符串"></a>NSMutableString:是NSString的子类，是可变字符串</h1><hr>
<pre><code>因为是可变字符串，所以修改都是本身，没有返回值
 //创建一个空字符串
    NSMutableString *str=[NSMutableString string];
    [str appendString:@&quot;lnj&quot;];
    NSLog(@&quot;%@&quot;,str);
//开发中常用方式：NSMutableString str=[NSMutableString stringWithFormat:@&quot;lnj&quot;];
</code></pre><hr>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><hr>
<pre><code>添加：
[str appendString:@&quot;lnj&quot;];
[str appendFormat:@&quot;%i&quot;,10];
删除路径中文件的扩展名：
[str deleteCharactersInRange:&lt;#(NSRange)#&gt;]
在某字符前面插入某某字符串
[str insertString:&lt;#(nonnull NSString *)#&gt; atIndex:&lt;#(NSUInteger)#&gt;]
替换：此方法返回值是NSUItnger，代表替换了多少个字符串
[str replaceOccurrencesOfString:&lt;#(nonnull NSString *)#&gt; withString:&lt;#(nonnull NSString *)#&gt; options:&lt;#(NSStringCompareOptions)#&gt; range:&lt;#(NSRange)#&gt;]
参数分别为：套替换的字符串，新字符串，0（如果枚举参数用不上，传入0即可，代表使用系统默认处理方式），范围。
</code></pre><hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/06/OC笔记_02/" rel="next" title="OC语言笔记_02">
                <i class="fa fa-chevron-left"></i> OC语言笔记_02
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/06/OC语言笔记_01/" rel="prev" title="OC语言笔记_01">
                OC语言笔记_01 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Qiang" />
          <p class="site-author-name" itemprop="name">Qiang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">49</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#autoreleasepool"><span class="nav-number">1.</span> <span class="nav-text">autoreleasepool</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ARC"><span class="nav-number">2.</span> <span class="nav-text">ARC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对多个对象的内存管理"><span class="nav-number">2.1.</span> <span class="nav-text">对多个对象的内存管理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#category"><span class="nav-number">3.</span> <span class="nav-text">category</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分类的格式"><span class="nav-number">3.1.</span> <span class="nav-text">分类的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名分类（类扩展）"><span class="nav-number">3.2.</span> <span class="nav-text">匿名分类（类扩展）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Block"><span class="nav-number">4.</span> <span class="nav-text">Block</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#block和typedef"><span class="nav-number">4.1.</span> <span class="nav-text">block和typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#block使用场景"><span class="nav-number">4.2.</span> <span class="nav-text">block使用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协议protocol"><span class="nav-number">5.</span> <span class="nav-text">协议protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用场景"><span class="nav-number">5.1.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#oc字符串"><span class="nav-number">6.</span> <span class="nav-text">oc字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的读写"><span class="nav-number">6.1.</span> <span class="nav-text">字符串的读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串比较"><span class="nav-number">6.2.</span> <span class="nav-text">字符串比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串搜索"><span class="nav-number">6.3.</span> <span class="nav-text">字符串搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串截取"><span class="nav-number">6.4.</span> <span class="nav-text">字符串截取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串替换"><span class="nav-number">6.5.</span> <span class="nav-text">字符串替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和路径"><span class="nav-number">6.6.</span> <span class="nav-text">字符串和路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串转换"><span class="nav-number">6.7.</span> <span class="nav-text">字符串转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串和基本数据类型的转换"><span class="nav-number">6.7.1.</span> <span class="nav-text">字符串和基本数据类型的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NSMutableString-是NSString的子类，是可变字符串"><span class="nav-number">7.</span> <span class="nav-text">NSMutableString:是NSString的子类，是可变字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用方法"><span class="nav-number">7.1.</span> <span class="nav-text">常用方法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
